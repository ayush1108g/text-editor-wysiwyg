{"ast":null,"code":"/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\n'use strict';\n\n/**\r\n * @description utility function\r\n */\nconst util = {\n  _d: null,\n  _w: null,\n  isIE: null,\n  isIE_Edge: null,\n  isOSX_IOS: null,\n  isChromium: null,\n  isResizeObserverSupported: null,\n  _propertiesInit: function () {\n    if (this._d) return;\n    this._d = document;\n    this._w = window;\n    this.isIE = navigator.userAgent.indexOf('Trident') > -1;\n    this.isIE_Edge = navigator.userAgent.indexOf('Trident') > -1 || navigator.appVersion.indexOf('Edge') > -1;\n    this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\n    this.isChromium = !!window.chrome;\n    this.isResizeObserverSupported = typeof ResizeObserver === 'function';\n  },\n  _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',\n  /**\r\n   * @description HTML Reserved Word Converter.\r\n   * @param {String} contents \r\n   * @returns {String} HTML string\r\n   * @private\r\n   */\n  _HTMLConvertor: function (contents) {\n    const ec = {\n      '&': '&amp;',\n      '\\u00A0': '&nbsp;',\n      '\\'': '&apos;',\n      '\"': '&quot;',\n      '<': '&lt;',\n      '>': '&gt;'\n    };\n    return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n  /**\r\n   * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n   */\n  zeroWidthSpace: String.fromCharCode(8203),\n  /**\r\n   * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n   */\n  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),\n  /**\r\n   * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n   */\n  onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),\n  fontValueMap: {\n    'xx-small': 1,\n    'x-small': 2,\n    'small': 3,\n    'medium': 4,\n    'large': 5,\n    'x-large': 6,\n    'xx-large': 7\n  },\n  /**\r\n   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n   * @param {String|Node} text String value or Node\r\n   * @returns {Boolean}\r\n   */\n  onlyZeroWidthSpace: function (text) {\n    if (text === null || text === undefined) return false;\n    if (typeof text !== 'string') text = text.textContent;\n    return text === '' || this.onlyZeroWidthRegExp.test(text);\n  },\n  /**\r\n   * @description Gets XMLHttpRequest object\r\n   * @returns {XMLHttpRequest|ActiveXObject}\r\n   */\n  getXMLHttpRequest: function () {\n    /** IE */\n    if (this._w.ActiveXObject) {\n      try {\n        return new ActiveXObject('Msxml2.XMLHTTP');\n      } catch (e) {\n        try {\n          return new ActiveXObject('Microsoft.XMLHTTP');\n        } catch (e1) {\n          return null;\n        }\n      }\n    }\n    /** netscape */else if (this._w.XMLHttpRequest) {\n      return new XMLHttpRequest();\n    }\n    /** fail */else {\n      return null;\n    }\n  },\n  /**\r\n   * @description Object.values\r\n   * @param {Object|null} obj Object parameter.\r\n   * @returns {Array}\r\n   */\n  getValues: function (obj) {\n    return !obj ? [] : this._w.Object.keys(obj).map(function (i) {\n      return obj[i];\n    });\n  },\n  /**\r\n   * @description Convert the CamelCase To the KebabCase.\r\n   * @param {String|Array} param [Camel string]\r\n   * @returns {String|Array}\r\n   */\n  camelToKebabCase: function (param) {\n    if (typeof param === 'string') {\n      return param.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n      });\n    } else {\n      return param.map(function (str) {\n        return util.camelToKebabCase(str);\n      });\n    }\n  },\n  /**\r\n   * @description Convert the KebabCase To the CamelCase.\r\n   * @param {String|Array} param [KebabCase string]\r\n   * @returns {String|Array}\r\n   */\n  kebabToCamelCase: function (param) {\n    if (typeof param === 'string') {\n      return param.replace(/-[a-zA-Z]/g, function (letter) {\n        return letter.replace('-', '').toUpperCase();\n      });\n    } else {\n      return param.map(function (str) {\n        return util.camelToKebabCase(str);\n      });\n    }\n  },\n  /**\r\n   * @description Create Element node\r\n   * @param {String} elementName Element name\r\n   * @returns {Element}\r\n   */\n  createElement: function (elementName) {\n    return this._d.createElement(elementName);\n  },\n  /**\r\n   * @description Create text node\r\n   * @param {String} text text contents\r\n   * @returns {Node}\r\n   */\n  createTextNode: function (text) {\n    return this._d.createTextNode(text || '');\n  },\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLEncoder: function (contents) {\n    const ec = {\n      '<': '$lt;',\n      '>': '$gt;'\n    };\n    return contents.replace(/<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLDecoder: function (contents) {\n    const ec = {\n      '$lt;': '<',\n      '$gt;': '>'\n    };\n    return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n  /**\r\n   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n   * @param {Object} obj Object\r\n   * @param {String} key obj.key\r\n   * @returns {Boolean}\r\n   */\n  hasOwn: function (obj, key) {\n    return this._hasOwn.call(obj, key);\n  },\n  _hasOwn: Object.prototype.hasOwnProperty,\n  /**\r\n   * @deprecated\r\n   * @description Get the the tag path of the arguments value\r\n   * If not found, return the first found value\r\n   * @param {Array} nameArray File name array\r\n   * @param {String} extension js, css\r\n   * @returns {String}\r\n   */\n  getIncludePath: function (nameArray, extension) {\n    let path = '';\n    const pathList = [];\n    const tagName = extension === 'js' ? 'script' : 'link';\n    const src = extension === 'js' ? 'src' : 'href';\n    let fileName = '(?:';\n    for (let i = 0, len = nameArray.length; i < len; i++) {\n      fileName += nameArray[i] + (i < len - 1 ? '|' : ')');\n    }\n    const regExp = new this._w.RegExp('(^|.*[\\\\/])' + fileName + '(\\\\.[^\\\\/]+)?\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n    const extRegExp = new this._w.RegExp('.+\\\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n    for (let c = this._d.getElementsByTagName(tagName), i = 0; i < c.length; i++) {\n      if (extRegExp.test(c[i][src])) {\n        pathList.push(c[i]);\n      }\n    }\n    for (let i = 0; i < pathList.length; i++) {\n      let editorTag = pathList[i][src].match(regExp);\n      if (editorTag) {\n        path = editorTag[0];\n        break;\n      }\n    }\n    if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';\n    -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\n    if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';\n    return path;\n  },\n  /**\r\n   * @deprecated\r\n   * @description Returns the CSS text that has been applied to the current page.\r\n   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n   * @returns {String} Styles string\r\n   */\n  getPageStyle: function (doc) {\n    let cssText = '';\n    const sheets = (doc || this._d).styleSheets;\n    for (let i = 0, len = sheets.length, rules; i < len; i++) {\n      try {\n        rules = sheets[i].cssRules;\n      } catch (e) {\n        continue;\n      }\n      if (rules) {\n        for (let c = 0, cLen = rules.length; c < cLen; c++) {\n          cssText += rules[c].cssText;\n        }\n      }\n    }\n    return cssText;\n  },\n  /**\r\n   * @description Get the argument iframe's document object\r\n   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n   * @returns {Document}\r\n   */\n  getIframeDocument: function (iframe) {\n    let wDocument = iframe.contentWindow || iframe.contentDocument;\n    if (wDocument.document) wDocument = wDocument.document;\n    return wDocument;\n  },\n  /**\r\n   * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n   * @param {Element} element Element object\r\n   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n   * @returns {String}\r\n   */\n  getAttributesToString: function (element, exceptAttrs) {\n    if (!element.attributes) return '';\n    const attrs = element.attributes;\n    let attrString = '';\n    for (let i = 0, len = attrs.length; i < len; i++) {\n      if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\n      attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\n    }\n    return attrString;\n  },\n  /**\r\n   * @descriptionGets Get the length in bytes of a string.\r\n   * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n   * @param {String} text String text\r\n   * @returns {Number}\r\n   */\n  getByteLength: function (text) {\n    if (!text || !text.toString) return 0;\n    text = text.toString();\n    const encoder = this._w.encodeURIComponent;\n    let cr, cl;\n    if (this.isIE_Edge) {\n      cl = this._w.unescape(encoder(text)).length;\n      cr = 0;\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n      return cl + cr;\n    } else {\n      cl = new this._w.TextEncoder('utf-8').encode(text).length;\n      cr = 0;\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n      return cl + cr;\n    }\n  },\n  /**\r\n   * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isWysiwygDiv: function (element) {\n    return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));\n  },\n  /**\r\n   * @description It is judged whether it is the contenteditable property is false.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNonEditable: function (element) {\n    return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';\n  },\n  /**\r\n   * @description It is judged whether it is a node related to the text style.\r\n   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isTextStyleElement: function (element) {\n    return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);\n  },\n  /**\r\n   * @description It is judged whether it is the input element (INPUT, TEXTAREA)\r\n   * @param {Node} element The node to check\r\n   * @returns \r\n   */\n  isInputElement: function (element) {\n    return element && element.nodeType === 1 && /^(INPUT|TEXTAREA)$/i.test(element.nodeName);\n  },\n  /**\r\n   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__se__format__replace_xxx\")\r\n   * Format element also contain \"free format Element\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFormatElement: function (element) {\n    return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__replace_.+(\\\\s|$)|(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n  /**\r\n   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__se__format__range_xxx\")\r\n   * Range format element is wrap the \"format element\" and \"component\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isRangeFormatElement: function (element) {\n    return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range_.+(\\\\s|$)'));\n  },\n  /**\r\n   * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__se__format__range__closure_xxx\")\r\n   * Closure range format elements is included in the range format element.\r\n   *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureRangeFormatElement: function (element) {\n    return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range__closure_.+(\\\\s|$)'));\n  },\n  /**\r\n   * @description It is judged whether it is the free format element. (PRE | class=\"__se__format__free_xxx\")\r\n   * Free format elements is included in the format element.\r\n   * Free format elements's line break is \"BR\" tag.\r\n   * ※ Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFreeFormatElement: function (element) {\n    return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n  /**\r\n   * @description It is judged whether it is the closure free format element. (class=\"__se__format__free__closure_xxx\")\r\n   * Closure free format elements is included in the free format element.\r\n   *  - Closure free format elements's line break is \"BR\" tag.\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureFreeFormatElement: function (element) {\n    return element && element.nodeType === 1 && this.hasClass(element, '(\\\\s|^)__se__format__free__closure_.+(\\\\s|$)');\n  },\n  /**\r\n   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"se-component\") and table, hr\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isComponent: function (element) {\n    return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\n  },\n  /**\r\n   * @description Checks for \"__se__uneditable\" in the class list.\r\n   * Components with class \"__se__uneditable\" cannot be modified.\r\n   * @param {Element} element The element to check\r\n   * @returns {Boolean}\r\n   */\n  isUneditableComponent: function (element) {\n    return element && this.hasClass(element, '__se__uneditable');\n  },\n  /**\r\n   * @description It is judged whether it is the component [img, iframe] cover(class=\"se-component\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isMediaComponent: function (element) {\n    return element && /se-component/.test(element.className);\n  },\n  /**\r\n   * @description It is judged whether it is the not checking node. (class=\"katex\", \"__se__tag\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNotCheckingNode: function (element) {\n    return element && /katex|__se__tag/.test(element.className);\n  },\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFormatElement: function (element, validation) {\n    if (!element) return null;\n    if (!validation) {\n      validation = function () {\n        return true;\n      };\n    }\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element)) element.firstElementChild;\n      if (this.isFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n    return null;\n  },\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getRangeFormatElement: function (element, validation) {\n    if (!element) return null;\n    if (!validation) {\n      validation = function () {\n        return true;\n      };\n    }\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\n      element = element.parentNode;\n    }\n    return null;\n  },\n  /**\r\n   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFreeFormatElement: function (element, validation) {\n    if (!element) return null;\n    if (!validation) {\n      validation = function () {\n        return true;\n      };\n    }\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n    return null;\n  },\n  /**\r\n   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getClosureFreeFormatElement: function (element, validation) {\n    if (!element) return null;\n    if (!validation) {\n      validation = function () {\n        return true;\n      };\n    }\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n    return null;\n  },\n  /**\r\n   * @description Add style and className of copyEl to originEl\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   * @param {Array|null} blacklist Blacklist array(LowerCase)\r\n   */\n  copyTagAttributes: function (originEl, copyEl, blacklist) {\n    if (copyEl.style.cssText) {\n      const copyStyles = copyEl.style;\n      for (let i = 0, len = copyStyles.length; i < len; i++) {\n        originEl.style[copyStyles[i]] = copyStyles[copyStyles[i]];\n      }\n    }\n    const attrs = copyEl.attributes;\n    for (let i = 0, len = attrs.length, name; i < len; i++) {\n      name = attrs[i].name.toLowerCase();\n      if (blacklist && blacklist.indexOf(name) > -1 || !attrs[i].value) originEl.removeAttribute(name);else if (name !== 'style') originEl.setAttribute(attrs[i].name, attrs[i].value);\n    }\n  },\n  /**\r\n   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__se__format__\" class\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyFormatAttributes: function (originEl, copyEl) {\n    copyEl = copyEl.cloneNode(false);\n    copyEl.className = copyEl.className.replace(/(\\s|^)__se__format__[^\\s]+/g, '');\n    this.copyTagAttributes(originEl, copyEl);\n  },\n  /**\r\n   * @description Get the item from the array that matches the condition.\r\n   * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n   * @param {Function|null} validation Conditional function\r\n   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n   * If false, returns only one item that meet the criteria otherwise return null.\r\n   * @returns {Array|Node|null}\r\n   */\n  getArrayItem: function (array, validation, multi) {\n    if (!array || array.length === 0) return null;\n    validation = validation || function () {\n      return true;\n    };\n    const arr = [];\n    for (let i = 0, len = array.length, a; i < len; i++) {\n      a = array[i];\n      if (validation(a)) {\n        if (!multi) return a;else arr.push(a);\n      }\n    }\n    return !multi ? null : arr;\n  },\n  /**\r\n   * @description Check if an array contains an element \r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to check for\r\n   * @returns {Boolean}\r\n   */\n  arrayIncludes: function (array, element) {\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  },\n  /**\r\n   * @description Get the index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to find index\r\n   * @returns {Number}\r\n   */\n  getArrayIndex: function (array, element) {\n    let idx = -1;\n    for (let i = 0, len = array.length; i < len; i++) {\n      if (array[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n    return idx;\n  },\n  /**\r\n   * @description Get the next index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  nextIdx: function (array, item) {\n    let idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx + 1;\n  },\n  /**\r\n   * @description Get the previous index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array Element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  prevIdx: function (array, item) {\n    let idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx - 1;\n  },\n  /**\r\n   * @description Returns the index compared to other sibling nodes.\r\n   * @param {Node} node The Node to find index\r\n   * @returns {Number}\r\n   */\n  getPositionIndex: function (node) {\n    let idx = 0;\n    while (node = node.previousSibling) {\n      idx += 1;\n    }\n    return idx;\n  },\n  /**\r\n   * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n   * @param {Node} node The Node to find position path\r\n   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n   * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n   * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n   * Do not use unless absolutely necessary.\r\n   * @returns {Array}\r\n   */\n  getNodePath: function (node, parentNode, _newOffsets) {\n    const path = [];\n    let finds = true;\n    this.getParentElement(node, function (el) {\n      if (el === parentNode) finds = false;\n      if (finds && !this.isWysiwygDiv(el)) {\n        // merge text nodes\n        if (_newOffsets && el.nodeType === 3) {\n          let temp = null,\n            tempText = null;\n          _newOffsets.s = _newOffsets.e = 0;\n          let previous = el.previousSibling;\n          while (previous && previous.nodeType === 3) {\n            tempText = previous.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.s += tempText.length;\n            el.textContent = tempText + el.textContent;\n            temp = previous;\n            previous = previous.previousSibling;\n            this.removeItem(temp);\n          }\n          let next = el.nextSibling;\n          while (next && next.nodeType === 3) {\n            tempText = next.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.e += tempText.length;\n            el.textContent += tempText;\n            temp = next;\n            next = next.nextSibling;\n            this.removeItem(temp);\n          }\n        }\n\n        // index push\n        path.push(el);\n      }\n      return false;\n    }.bind(this));\n    return path.map(this.getPositionIndex).reverse();\n  },\n  /**\r\n   * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n   * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n   * @param {Node} parentNode Base parent element\r\n   * @returns {Node}\r\n   */\n  getNodeFromPath: function (offsets, parentNode) {\n    let current = parentNode;\n    let nodes;\n    for (let i = 0, len = offsets.length; i < len; i++) {\n      nodes = current.childNodes;\n      if (nodes.length === 0) break;\n      if (nodes.length <= offsets[i]) {\n        current = nodes[nodes.length - 1];\n      } else {\n        current = nodes[offsets[i]];\n      }\n    }\n    return current;\n  },\n  /**\r\n   * @description Compares the style and class for equal values.\r\n   * Returns true if both are text nodes.\r\n   * @param {Node} a Node to compare\r\n   * @param {Node} b Node to compare\r\n   * @returns {Boolean}\r\n   */\n  isSameAttributes: function (a, b) {\n    if (a.nodeType === 3 && b.nodeType === 3) return true;\n    if (a.nodeType === 3 || b.nodeType === 3) return false;\n    const style_a = a.style;\n    const style_b = b.style;\n    let compStyle = 0;\n    for (let i = 0, len = style_a.length; i < len; i++) {\n      if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\n    }\n    const class_a = a.classList;\n    const class_b = b.classList;\n    const reg = this._w.RegExp;\n    let compClass = 0;\n    for (let i = 0, len = class_a.length; i < len; i++) {\n      if (reg('(\\s|^)' + class_a[i] + '(\\s|$)').test(class_b.value)) compClass++;\n    }\n    return compStyle === style_b.length && compStyle === style_a.length && compClass === class_b.length && compClass === class_a.length;\n  },\n  /**\r\n   * @description Check the line element(util.isFormatElement) is empty.\r\n   * @param {Element} element Format element node\r\n   * @returns {Boolean}\r\n   */\n  isEmptyLine: function (element) {\n    return !element || !element.parentNode || !element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && element.children.length === 0 && this.onlyZeroWidthSpace(element.textContent);\n  },\n  /**\r\n   * @description Check the span's attributes are empty.\r\n   * @param {Element|null} element Element node\r\n   * @returns {Boolean}\r\n   */\n  isSpanWithoutAttr: function (element) {\n    return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;\n  },\n  /**\r\n   * @description Check the node is a list (ol, ul)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isList: function (node) {\n    return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a list cell (li)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isListCell: function (node) {\n    return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isTable: function (node) {\n    return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a table cell (td, th)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isCell: function (node) {\n    return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a break node (BR)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isBreak: function (node) {\n    return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a anchor node (A)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isAnchor: function (node) {\n    return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isMedia: function (node) {\n    return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n  /**\r\n   * @description Check the node is a figure tag or util.isMedia()\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isFigures: function (node) {\n    return node && (this.isMedia(node) || /^(FIGURE)$/i.test(typeof node === 'string' ? node : node.nodeName));\n  },\n  /**\r\n   * @description Checks for numeric (with decimal point).\r\n   * @param {String|Number} text Text string or number\r\n   * @returns {Boolean}\r\n   */\n  isNumber: function (text) {\n    return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + '');\n  },\n  /**\r\n   * @description Get a number.\r\n   * @param {String|Number} text Text string or number\r\n   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n   * @returns {Number}\r\n   */\n  getNumber: function (text, maxDec) {\n    if (!text) return 0;\n    let number = (text + '').match(/-?\\d+(\\.\\d+)?/);\n    if (!number || !number[0]) return 0;\n    number = number[0];\n    return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\n  },\n  /**\r\n   * @description Get all \"children\" of the argument value element (Without text nodes)\r\n   * @param {Element} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildren: function (element, validation) {\n    const children = [];\n    if (!element || !element.children || element.children.length === 0) return children;\n    validation = validation || function () {\n      return true;\n    };\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n      if (!!current.children) {\n        for (let i = 0, len = current.children.length; i < len; i++) {\n          recursionFunc(current.children[i]);\n        }\n      }\n    })(element);\n    return children;\n  },\n  /**\r\n   * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n   * @param {Node} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildNodes: function (element, validation) {\n    const children = [];\n    if (!element || element.childNodes.length === 0) return children;\n    validation = validation || function () {\n      return true;\n    };\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n      for (let i = 0, len = current.childNodes.length; i < len; i++) {\n        recursionFunc(current.childNodes[i]);\n      }\n    })(element);\n    return children;\n  },\n  /**\r\n   * @description Returns the number of parents nodes.\r\n   * \"0\" when the parent node is the WYSIWYG area.\r\n   * \"-1\" when the element argument is the WYSIWYG area.\r\n   * @param {Node} element The element to check\r\n   * @returns {Number}\r\n   */\n  getElementDepth: function (element) {\n    if (!element || this.isWysiwygDiv(element)) return -1;\n    let depth = 0;\n    element = element.parentNode;\n    while (element && !this.isWysiwygDiv(element)) {\n      depth += 1;\n      element = element.parentNode;\n    }\n    return depth;\n  },\n  /**\r\n   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n   * @param {Node} a Node to compare.\r\n   * @param {Node} b Node to compare.\r\n   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n   */\n  compareElements: function (a, b) {\n    let aNode = a,\n      bNode = b;\n    while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\n      aNode = aNode.parentNode;\n      bNode = bNode.parentNode;\n    }\n    if (!aNode || !bNode) return {\n      ancestor: null,\n      a: a,\n      b: b,\n      result: 0\n    };\n    const children = aNode.parentNode.childNodes;\n    const aIndex = this.getArrayIndex(children, aNode);\n    const bIndex = this.getArrayIndex(children, bNode);\n    return {\n      ancestor: aNode.parentNode,\n      a: aNode,\n      b: bNode,\n      result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\n    };\n  },\n  /**\r\n   * @description Get the parent element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getParentElement: function (element, query) {\n    let check;\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      let attr;\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + query + '$';\n      }\n      const regExp = new this._w.RegExp(query, 'i');\n      check = function (el) {\n        return regExp.test(el[attr]);\n      };\n    }\n    while (element && !check(element)) {\n      if (this.isWysiwygDiv(element)) {\n        return null;\n      }\n      element = element.parentNode;\n    }\n    return element;\n  },\n  /**\r\n   * @description Get the child element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getChildElement: function (element, query, last) {\n    let check;\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      let attr;\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + (query === 'text' ? '#' + query : query) + '$';\n      }\n      const regExp = new this._w.RegExp(query, 'i');\n      check = function (el) {\n        return regExp.test(el[attr]);\n      };\n    }\n    const childList = this.getListChildNodes(element, function (current) {\n      return check(current);\n    });\n    return childList[last ? childList.length - 1 : 0];\n  },\n  /**\r\n   * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n   * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n   * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n   * { sc: \"first\", ec: \"last\" }\r\n   * @param {Node} first First element\r\n   * @param {Node|null} last Last element\r\n   * @returns {Object}\r\n   */\n  getEdgeChildNodes: function (first, last) {\n    if (!first) return;\n    if (!last) last = first;\n    while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;\n    while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) last = last.lastChild;\n    return {\n      sc: first,\n      ec: last || first\n    };\n  },\n  /**\r\n   * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n   * @param {Node} element Target node\r\n   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n   * @returns {Object}\r\n   */\n  getOffset: function (element, wysiwygFrame) {\n    let offsetLeft = 0;\n    let offsetTop = 0;\n    let offsetElement = element.nodeType === 3 ? element.parentElement : element;\n    const wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\n    while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {\n      offsetLeft += offsetElement.offsetLeft;\n      offsetTop += offsetElement.offsetTop;\n      offsetElement = offsetElement.offsetParent;\n    }\n    const iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\n    return {\n      left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\n      top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\n    };\n  },\n  /**\r\n   * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n   * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n   * @param {Number} aStart Start index of \"a\"\r\n   * @param {Number} aEnd End index of \"a\"\r\n   * @param {Number} bStart Start index of \"b\"\r\n   * @param {Number} bEnd Start index of \"b\"\r\n   * @returns {Number}\r\n   */\n  getOverlapRangeAtIndex: function (aStart, aEnd, bStart, bEnd) {\n    if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\n    const overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\n    return (overlap < 0 ? overlap * -1 : overlap) + 1;\n  },\n  /**\r\n   * @description Set the text content value of the argument value element\r\n   * @param {Node} element Element to replace text content\r\n   * @param {String} txt Text to be applied\r\n   */\n  changeTxt: function (element, txt) {\n    if (!element || !txt) return;\n    element.textContent = txt;\n  },\n  /**\r\n   * @description Replace element\r\n   * @param {Element} element Target element\r\n   * @param {String|Element} newElement String or element of the new element to apply\r\n   */\n  changeElement: function (element, newElement) {\n    if (typeof newElement === 'string') {\n      if (element.outerHTML) {\n        element.outerHTML = newElement;\n      } else {\n        const doc = this.createElement('DIV');\n        doc.innerHTML = newElement;\n        newElement = doc.firstChild;\n        element.parentNode.replaceChild(newElement, element);\n      }\n    } else if (newElement.nodeType === 1) {\n      element.parentNode.replaceChild(newElement, element);\n    }\n  },\n  /**\r\n   * @description Set style, if all styles are deleted, the style properties are deleted.\r\n   * @param {Element} element Element to set style\r\n   * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n   * @param {String|Number} value Style value\r\n   */\n  setStyle: function (element, styleName, value) {\n    element.style[styleName] = value;\n    if (!value && !element.style.cssText) {\n      element.removeAttribute('style');\n    }\n  },\n  /**\r\n   * @description Determine whether any of the matched elements are assigned the given class\r\n   * @param {Element} element Elements to search class name\r\n   * @param {String} className Class name to search for\r\n   * @returns {Boolean}\r\n   */\n  hasClass: function (element, className) {\n    if (!element) return;\n    return new this._w.RegExp(className).test(element.className);\n  },\n  /**\r\n   * @description Append the className value of the argument value element\r\n   * @param {Element} element Elements to add class name\r\n   * @param {String} className Class name to be add\r\n   */\n  addClass: function (element, className) {\n    if (!element) return;\n    const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    if (check.test(element.className)) return;\n    element.className += (element.className.length > 0 ? ' ' : '') + className;\n  },\n  /**\r\n   * @description Delete the className value of the argument value element\r\n   * @param {Element} element Elements to remove class name\r\n   * @param {String} className Class name to be remove\r\n   */\n  removeClass: function (element, className) {\n    if (!element) return;\n    const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    element.className = element.className.replace(check, ' ').trim();\n    if (!element.className.trim()) element.removeAttribute('class');\n  },\n  /**\r\n   * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n   * @param {Element} element Elements to replace class name\r\n   * @param {String} className Class name to be change\r\n   * @returns {Boolean|undefined}\r\n   */\n  toggleClass: function (element, className) {\n    if (!element) return;\n    let result = false;\n    const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    if (check.test(element.className)) {\n      element.className = element.className.replace(check, ' ').trim();\n    } else {\n      element.className += ' ' + className;\n      result = true;\n    }\n    if (!element.className.trim()) element.removeAttribute('class');\n    return result;\n  },\n  /**\r\n   * @description Checks if element can't be easily enabled\r\n   * @param {Element} element Element to check for\r\n   */\n  isImportantDisabled: function (element) {\n    return element.hasAttribute('data-important-disabled');\n  },\n  /**\r\n   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n   * core.codeViewDisabledButtons (An array of buttons whose class name is not \"se-code-view-enabled\")\r\n   * core.resizingDisabledButtons (An array of buttons whose class name is not \"se-resizing-enabled\")\r\n   * @param {Boolean} disabled Disabled value\r\n   * @param {Array|HTMLCollection|NodeList} buttonList Button array\r\n   * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)\r\n   */\n  setDisabledButtons: function (disabled, buttonList, important) {\n    for (let i = 0, len = buttonList.length; i < len; i++) {\n      let button = buttonList[i];\n      if (important || !this.isImportantDisabled(button)) button.disabled = disabled;\n      if (important) {\n        if (disabled) {\n          button.setAttribute('data-important-disabled', '');\n        } else {\n          button.removeAttribute('data-important-disabled');\n        }\n      }\n    }\n  },\n  /**\r\n   * @description Delete argumenu value element\r\n   * @param {Node} item Node to be remove\r\n   */\n  removeItem: function (item) {\n    if (!item) return;\n    if (typeof item.remove === 'function') item.remove();else if (item.parentNode) item.parentNode.removeChild(item);\n  },\n  /**\r\n   * @description Delete all parent nodes that match the condition.\r\n   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n   * @param {Node} item Node to be remove\r\n   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n   * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n   */\n  removeItemAllParents: function (item, validation, stopParent) {\n    if (!item) return null;\n    let cc = null;\n    if (!validation) {\n      validation = function (current) {\n        if (current === stopParent || this.isComponent(current)) return false;\n        const text = current.textContent.trim();\n        return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\n      }.bind(this);\n    }\n    (function recursionFunc(element) {\n      if (!util.isWysiwygDiv(element)) {\n        const parent = element.parentNode;\n        if (parent && validation(element)) {\n          cc = {\n            sc: element.previousElementSibling,\n            ec: element.nextElementSibling\n          };\n          util.removeItem(element);\n          recursionFunc(parent);\n        }\n      }\n    })(item);\n    return cc;\n  },\n  /**\r\n   * @description Detach Nested all nested lists under the \"baseNode\".\r\n   * Returns a list with nested removed.\r\n   * @param {Node} baseNode Element on which to base.\r\n   * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n   * @returns {Element}\r\n   */\n  detachNestedList: function (baseNode, all) {\n    const rNode = this._deleteNestedList(baseNode);\n    let rangeElement, cNodes;\n    if (rNode) {\n      rangeElement = rNode.cloneNode(false);\n      cNodes = rNode.childNodes;\n      const index = this.getPositionIndex(baseNode);\n      while (cNodes[index]) {\n        rangeElement.appendChild(cNodes[index]);\n      }\n    } else {\n      rangeElement = baseNode;\n    }\n    let rChildren;\n    if (!all) {\n      const depth = this.getElementDepth(baseNode) + 2;\n      rChildren = this.getListChildren(baseNode, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;\n      }.bind(this));\n    } else {\n      rChildren = this.getListChildren(rangeElement, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling;\n      }.bind(this));\n    }\n    for (let i = 0, len = rChildren.length; i < len; i++) {\n      this._deleteNestedList(rChildren[i]);\n    }\n    if (rNode) {\n      rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\n      if (cNodes && cNodes.length === 0) this.removeItem(rNode);\n    }\n    return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\n  },\n  /**\r\n   * @description Sub function of util.detachNestedList method.\r\n   * @private\r\n   */\n  _deleteNestedList: function (baseNode) {\n    const baseParent = baseNode.parentNode;\n    let sibling = baseParent;\n    let parent = sibling.parentNode;\n    let liSibling, liParent, child, index, c;\n    while (this.isListCell(parent)) {\n      index = this.getPositionIndex(baseNode);\n      liSibling = parent.nextElementSibling;\n      liParent = parent.parentNode;\n      child = sibling;\n      while (child) {\n        sibling = sibling.nextSibling;\n        if (this.isList(child)) {\n          c = child.childNodes;\n          while (c[index]) {\n            liParent.insertBefore(c[index], liSibling);\n          }\n          if (c.length === 0) this.removeItem(child);\n        } else {\n          liParent.appendChild(child);\n        }\n        child = sibling;\n      }\n      sibling = liParent;\n      parent = liParent.parentNode;\n    }\n    if (baseParent.children.length === 0) this.removeItem(baseParent);\n    return liParent;\n  },\n  /**\r\n   * @description Split all tags based on \"baseNode\"\r\n   * Returns the last element of the splited tag.\r\n   * @param {Node} baseNode Element or text node on which to base\r\n   * @param {Number|Node|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n   * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n   * @returns {Element}\r\n   */\n  splitElement: function (baseNode, offset, depth) {\n    if (this.isWysiwygDiv(baseNode)) return baseNode;\n    if (offset && !this.isNumber(offset)) {\n      const children = baseNode.childNodes;\n      let index = this.getPositionIndex(offset);\n      const prev = baseNode.cloneNode(false);\n      const next = baseNode.cloneNode(false);\n      for (let i = 0, len = children.length; i < len; i++) {\n        if (i < index) prev.appendChild(children[i]);else if (i > index) next.appendChild(children[i]);else continue;\n        i--;\n        len--;\n        index--;\n      }\n      if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);\n      if (next.childNodes.length > 0) baseNode.parentNode.insertBefore(next, baseNode.nextElementSibling);\n      return baseNode;\n    }\n    const bp = baseNode.parentNode;\n    let index = 0;\n    let suffixIndex = 1;\n    let next = true;\n    let newEl, children, temp;\n    if (!depth || depth < 0) depth = 0;\n    if (baseNode.nodeType === 3) {\n      index = this.getPositionIndex(baseNode);\n      if (offset >= 0 && baseNode.length !== offset) {\n        baseNode.splitText(offset);\n        const after = this.getNodeFromPath([index + 1], bp);\n        if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\n      }\n    } else if (baseNode.nodeType === 1) {\n      if (offset === 0) {\n        while (baseNode.firstChild) {\n          baseNode = baseNode.firstChild;\n        }\n        if (baseNode.nodeType === 3) {\n          const after = this.createTextNode(this.zeroWidthSpace);\n          baseNode.parentNode.insertBefore(after, baseNode);\n          baseNode = after;\n        }\n      }\n      if (!baseNode.previousSibling) {\n        if (this.getElementDepth(baseNode) === depth) next = false;\n      } else {\n        baseNode = baseNode.previousSibling;\n      }\n    }\n    if (baseNode.nodeType === 1) suffixIndex = 0;\n    let depthEl = baseNode;\n    while (this.getElementDepth(depthEl) > depth) {\n      index = this.getPositionIndex(depthEl) + suffixIndex;\n      depthEl = depthEl.parentNode;\n      temp = newEl;\n      newEl = depthEl.cloneNode(false);\n      children = depthEl.childNodes;\n      if (temp) {\n        if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\n          newEl.innerHTML = temp.firstElementChild.innerHTML;\n          util.removeItem(temp.firstElementChild);\n          if (temp.children.length > 0) newEl.appendChild(temp);\n        } else {\n          newEl.appendChild(temp);\n        }\n      }\n      while (children[index]) {\n        newEl.appendChild(children[index]);\n      }\n    }\n    if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';\n    const pElement = depthEl.parentNode;\n    if (next) depthEl = depthEl.nextSibling;\n    if (!newEl) return depthEl;\n    this.mergeSameTags(newEl, null, false);\n    this.mergeNestedTags(newEl, function (current) {\n      return this.isList(current);\n    }.bind(this));\n    if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);else newEl = depthEl;\n    if (this.isListCell(newEl) && newEl.children && this.isList(newEl.children[0])) {\n      newEl.insertBefore(this.createElement('BR'), newEl.children[0]);\n    }\n    if (bp.childNodes.length === 0) this.removeItem(bp);\n    return newEl;\n  },\n  /**\r\n   * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n   * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n   * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n   * @param {Element} element Element\r\n   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n   * @returns {Array} [offset, ..]\r\n   */\n  mergeSameTags: function (element, nodePathArray, onlyText) {\n    const inst = this;\n    const nodePathLen = nodePathArray ? nodePathArray.length : 0;\n    let offsets = null;\n    if (nodePathLen) {\n      offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\n    }\n    (function recursionFunc(current, depth, depthIndex) {\n      const children = current.childNodes;\n      for (let i = 0, len = children.length, child, next; i < len; i++) {\n        child = children[i];\n        next = children[i + 1];\n        if (!child) break;\n        if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {\n          if (inst.isTable(child) || inst.isListCell(child)) {\n            recursionFunc(child, depth + 1, i);\n          }\n          continue;\n        }\n        if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\n          // update nodePath\n          if (nodePathLen) {\n            let path, c, p, cDepth, spliceDepth;\n            for (let n = 0; n < nodePathLen; n++) {\n              path = nodePathArray[n];\n              if (path && path[depth] === i) {\n                c = child, p = current, cDepth = depth, spliceDepth = true;\n                while (cDepth >= 0) {\n                  if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\n                    spliceDepth = false;\n                    break;\n                  }\n                  c = child.parentNode;\n                  p = c.parentNode;\n                  cDepth--;\n                }\n                if (spliceDepth) {\n                  path.splice(depth, 1);\n                  path[depth] = i;\n                }\n              }\n            }\n          }\n\n          // merge tag\n          inst.copyTagAttributes(child, current);\n          current.parentNode.insertBefore(child, current);\n          inst.removeItem(current);\n        }\n        if (!next) {\n          if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\n          break;\n        }\n        if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\n          const childs = child.childNodes;\n          let childLength = 0;\n          for (let n = 0, nLen = childs.length; n < nLen; n++) {\n            if (childs[n].textContent.length > 0) childLength++;\n          }\n          const l = child.lastChild;\n          const r = next.firstChild;\n          let addOffset = 0;\n          if (l && r) {\n            const textOffset = l.nodeType === 3 && r.nodeType === 3;\n            addOffset = l.textContent.length;\n            let tempL = l.previousSibling;\n            while (tempL && tempL.nodeType === 3) {\n              addOffset += tempL.textContent.length;\n              tempL = tempL.previousSibling;\n            }\n            if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\n            if (nodePathLen) {\n              let path = null;\n              for (let n = 0; n < nodePathLen; n++) {\n                path = nodePathArray[n];\n                if (path && path[depth] > i) {\n                  if (depth > 0 && path[depth - 1] !== depthIndex) continue;\n                  path[depth] -= 1;\n                  if (path[depth + 1] >= 0 && path[depth] === i) {\n                    path[depth + 1] += childLength;\n                    if (textOffset) {\n                      if (l && l.nodeType === 3 && r && r.nodeType === 3) {\n                        offsets[n] += addOffset;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (child.nodeType === 3) {\n            addOffset = child.textContent.length;\n            child.textContent += next.textContent;\n            if (nodePathLen) {\n              let path = null;\n              for (let n = 0; n < nodePathLen; n++) {\n                path = nodePathArray[n];\n                if (path && path[depth] > i) {\n                  if (depth > 0 && path[depth - 1] !== depthIndex) continue;\n                  path[depth] -= 1;\n                  if (path[depth + 1] >= 0 && path[depth] === i) {\n                    path[depth + 1] += childLength;\n                    offsets[n] += addOffset;\n                  }\n                }\n              }\n            }\n          } else {\n            child.innerHTML += next.innerHTML;\n          }\n          inst.removeItem(next);\n          i--;\n        } else if (child.nodeType === 1) {\n          recursionFunc(child, depth + 1, i);\n        }\n      }\n    })(element, 0, 0);\n    return offsets;\n  },\n  /**\r\n   * @description Remove nested tags without other child nodes.\r\n   * @param {Element} element Element object\r\n   * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n   */\n  mergeNestedTags: function (element, validation) {\n    if (typeof validation === 'string') {\n      validation = function (current) {\n        return this.test(current.tagName);\n      }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));\n    } else if (typeof validation !== 'function') {\n      validation = function () {\n        return true;\n      };\n    }\n    (function recursionFunc(current) {\n      let children = current.children;\n      if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\n        const temp = children[0];\n        children = temp.children;\n        while (children[0]) {\n          current.appendChild(children[0]);\n        }\n        current.removeChild(temp);\n      }\n      for (let i = 0, len = current.children.length; i < len; i++) {\n        recursionFunc(current.children[i]);\n      }\n    })(element);\n  },\n  /**\r\n   * @description Delete a empty child node of argument element.\r\n   * @param {Element} element Element node\r\n   * @param {Node|null} notRemoveNode Do not remove node\r\n   * @param {boolean} forceDelete When all child nodes are deleted, the parent node is also deleted.\r\n   */\n  removeEmptyNode: function (element, notRemoveNode, forceDelete) {\n    const inst = this;\n    if (notRemoveNode) {\n      notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\n        return element === current.parentElement;\n      });\n    }\n    (function recursionFunc(current) {\n      if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\n      if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n          return -1;\n        }\n      } else {\n        const children = current.children;\n        for (let i = 0, len = children.length, r = 0; i < len; i++) {\n          if (!children[i + r] || inst.isComponent(children[i + r])) continue;\n          r += recursionFunc(children[i + r]);\n        }\n      }\n      return 0;\n    })(element);\n    if (element.childNodes.length === 0) {\n      if (forceDelete) {\n        this.removeItem(element);\n      } else {\n        element.innerHTML = '<br>';\n      }\n    }\n  },\n  /**\r\n   * @description Remove whitespace between tags in HTML string.\r\n   * @param {String} html HTML string\r\n   * @returns {String}\r\n   */\n  htmlRemoveWhiteSpace: function (html) {\n    if (!html) return '';\n    return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\\s+(?=<)/ig, function (m) {\n      return m.replace(/\\n/g, '').replace(/\\s+/, ' ');\n    });\n  },\n  /**\r\n  * @description HTML code compression\r\n  * @param {string} html HTML string\r\n  * @returns {string} HTML string\r\n  */\n  htmlCompress: function (html) {\n    return html.replace(/\\n/g, '').replace(/(>)(?:\\s+)(<)/g, '$1$2');\n  },\n  /**\r\n   * @description Sort a element array by depth of element.\r\n   * @param {Array} array Array object\r\n   * @param {Boolean} des true: descending order / false: ascending order\r\n   */\n  sortByDepth: function (array, des) {\n    const t = !des ? -1 : 1;\n    const f = t * -1;\n    array.sort(function (a, b) {\n      if (!this.isListCell(a) || !this.isListCell(b)) return 0;\n      a = this.getElementDepth(a);\n      b = this.getElementDepth(b);\n      return a > b ? t : a < b ? f : 0;\n    }.bind(this));\n  },\n  _isExcludeSelectionElement: function (element) {\n    return !/FIGCAPTION/i.test(element.nodeName) && (this.isComponent(element) || /FIGURE/i.test(element.nodeName));\n  },\n  /**\r\n   * @description Nodes that need to be added without modification when changing text nodes\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isIgnoreNodeChange: function (element) {\n    return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\n  },\n  /**\r\n   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n   * @param {Node|String} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isMaintainedNode: function (element) {\n    return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);\n  },\n  /**\r\n   * @description Node with font-size style\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isSizeNode: function (element) {\n    return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\n  },\n  /**\r\n   * @description Nodes without text\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _notTextNode: function (element) {\n    return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));\n  },\n  /**\r\n   * @deprecated\r\n   * @description Check disallowed tags\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _disallowedTags: function (element) {\n    return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\n  },\n  /**\r\n   * @description Create whitelist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsWhitelist: function (list) {\n    return new RegExp('<\\\\/?\\\\b(?!\\\\b' + (list || '').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n  /**\r\n   * @description Create blacklist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?:\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsBlacklist: function (list) {\n    return new RegExp('<\\\\/?\\\\b(?:\\\\b' + (list || '^').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n  /**\r\n   * @description Fix tags that do not fit the editor format.\r\n   * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n   * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)\r\n   * @param {Function} classNameFilter Class name filter function\r\n   * @private\r\n   */\n  _consistencyCheckOfHTML: function (documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, classNameFilter) {\n    /**\r\n     * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n     * So check the node type and exclude the text no (current.nodeType !== 1)\r\n     */\n    const removeTags = [],\n      emptyTags = [],\n      wrongList = [],\n      withoutFormatCells = [];\n\n    // wrong position\n    const wrongTags = this.getListChildNodes(documentFragment, function (current) {\n      if (current.nodeType !== 1) {\n        if (this.isList(current.parentElement)) removeTags.push(current);\n        return false;\n      }\n\n      // white list\n      if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {\n        removeTags.push(current);\n        return false;\n      }\n\n      // empty tags\n      const nrtag = !this.getParentElement(current, this.isNotCheckingNode);\n      if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\n        emptyTags.push(current);\n        return false;\n      }\n\n      // wrong list\n      if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\n        wrongList.push(current);\n        return false;\n      }\n\n      // table cells\n      if (this.isCell(current)) {\n        const fel = current.firstElementChild;\n        if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\n          withoutFormatCells.push(current);\n          return false;\n        }\n      }\n\n      // class filter\n      if (nrtag && current.className) {\n        const className = new this._w.Array(current.classList).map(classNameFilter).join(' ').trim();\n        if (className) current.className = className;else current.removeAttribute('class');\n      }\n      const result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));\n      return result;\n    }.bind(this));\n    for (let i = 0, len = removeTags.length; i < len; i++) {\n      this.removeItem(removeTags[i]);\n    }\n    const checkTags = [];\n    for (let i = 0, len = wrongTags.length, t, p; i < len; i++) {\n      t = wrongTags[i];\n      p = t.parentNode;\n      if (!p || !p.parentNode) continue;\n      if (this.getParentElement(t, this.isListCell)) {\n        const cellChildren = t.childNodes;\n        for (let j = cellChildren.length - 1; len >= 0; j--) {\n          p.insertBefore(t, cellChildren[j]);\n        }\n        checkTags.push(t);\n      } else {\n        p.parentNode.insertBefore(t, p);\n        checkTags.push(p);\n      }\n    }\n    for (let i = 0, len = checkTags.length, t; i < len; i++) {\n      t = checkTags[i];\n      if (this.onlyZeroWidthSpace(t.textContent.trim())) {\n        this.removeItem(t);\n      }\n    }\n    for (let i = 0, len = emptyTags.length; i < len; i++) {\n      this.removeItem(emptyTags[i]);\n    }\n    for (let i = 0, len = wrongList.length, t, tp, children, p; i < len; i++) {\n      t = wrongList[i];\n      p = t.parentNode;\n      if (!p) continue;\n      tp = this.createElement('LI');\n      if (this.isFormatElement(t)) {\n        children = t.childNodes;\n        while (children[0]) {\n          tp.appendChild(children[0]);\n        }\n        p.insertBefore(tp, t);\n        this.removeItem(t);\n      } else {\n        t = t.nextSibling;\n        tp.appendChild(wrongList[i]);\n        p.insertBefore(tp, t);\n      }\n    }\n    for (let i = 0, len = withoutFormatCells.length, t, f; i < len; i++) {\n      t = withoutFormatCells[i];\n      f = this.createElement('DIV');\n      f.innerHTML = t.textContent.trim().length === 0 && t.children.length === 0 ? '<br>' : t.innerHTML;\n      t.innerHTML = f.outerHTML;\n    }\n  },\n  _setDefaultOptionStyle: function (options, defaultStyle) {\n    let optionStyle = '';\n    if (options.height) optionStyle += 'height:' + options.height + ';';\n    if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';\n    if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';\n    if (options.position) optionStyle += 'position:' + options.position + ';';\n    if (options.width) optionStyle += 'width:' + options.width + ';';\n    if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';\n    if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';\n    let top = '',\n      frame = '',\n      editor = '';\n    defaultStyle = optionStyle + defaultStyle;\n    const styleArr = defaultStyle.split(';');\n    for (let i = 0, len = styleArr.length, s; i < len; i++) {\n      s = styleArr[i].trim();\n      if (!s) continue;\n      if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\n        top += s + ';';\n        continue;\n      }\n      if (/^(min-|max-)?height\\s*:/.test(s)) {\n        if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {\n          options.height = 'auto';\n        }\n        frame += s + ';';\n        continue;\n      }\n      editor += s + ';';\n    }\n    return {\n      top: top,\n      frame: frame,\n      editor: editor\n    };\n  },\n  _setIframeDocument: function (frame, options) {\n    frame.setAttribute('scrolling', 'auto');\n    frame.contentDocument.head.innerHTML = '' + '<meta charset=\"utf-8\" />' + '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">' + this._setIframeCssTags(options);\n    frame.contentDocument.body.className = options._editableClass;\n    frame.contentDocument.body.setAttribute('contenteditable', true);\n  },\n  _setIframeCssTags: function (options) {\n    const linkNames = options.iframeCSSFileName;\n    const wRegExp = this._w.RegExp;\n    let tagString = '';\n    for (let f = 0, len = linkNames.length, path; f < len; f++) {\n      path = [];\n      if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\n        path.push(linkNames[f]);\n      } else {\n        const CSSFileName = new wRegExp('(^|.*[\\\\/])' + linkNames[f] + '(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$', 'i');\n        for (let c = document.getElementsByTagName('link'), i = 0, len = c.length, styleTag; i < len; i++) {\n          styleTag = c[i].href.match(CSSFileName);\n          if (styleTag) path.push(styleTag[0]);\n        }\n      }\n      if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\n      for (let i = 0, len = path.length; i < len; i++) {\n        tagString += '<link href=\"' + path[i] + '\" rel=\"stylesheet\">';\n      }\n    }\n    return tagString + (options.height === 'auto' ? '<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>' : '');\n  }\n};\nexport default util;","map":{"version":3,"names":["util","_d","_w","isIE","isIE_Edge","isOSX_IOS","isChromium","isResizeObserverSupported","_propertiesInit","document","window","navigator","userAgent","indexOf","appVersion","test","platform","chrome","ResizeObserver","_allowedEmptyNodeList","_HTMLConvertor","contents","ec","replace","m","zeroWidthSpace","String","fromCharCode","zeroWidthRegExp","RegExp","onlyZeroWidthRegExp","fontValueMap","onlyZeroWidthSpace","text","undefined","textContent","getXMLHttpRequest","ActiveXObject","e","e1","XMLHttpRequest","getValues","obj","Object","keys","map","i","camelToKebabCase","param","letter","toLowerCase","str","kebabToCamelCase","toUpperCase","createElement","elementName","createTextNode","HTMLEncoder","HTMLDecoder","hasOwn","key","_hasOwn","call","prototype","hasOwnProperty","getIncludePath","nameArray","extension","path","pathList","tagName","src","fileName","len","length","regExp","extRegExp","c","getElementsByTagName","push","editorTag","match","slice","location","href","name","getPageStyle","doc","cssText","sheets","styleSheets","rules","cssRules","cLen","getIframeDocument","iframe","wDocument","contentWindow","contentDocument","getAttributesToString","element","exceptAttrs","attributes","attrs","attrString","value","getByteLength","toString","encoder","encodeURIComponent","cr","cl","unescape","TextEncoder","encode","isWysiwygDiv","nodeType","hasClass","nodeName","isNonEditable","getAttribute","isTextStyleElement","isInputElement","isFormatElement","isComponent","isRangeFormatElement","isClosureRangeFormatElement","isFreeFormatElement","isClosureFreeFormatElement","className","isUneditableComponent","isMediaComponent","isNotCheckingNode","getFormatElement","validation","firstElementChild","parentNode","getRangeFormatElement","getFreeFormatElement","getClosureFreeFormatElement","copyTagAttributes","originEl","copyEl","blacklist","style","copyStyles","removeAttribute","setAttribute","copyFormatAttributes","cloneNode","getArrayItem","array","multi","arr","a","arrayIncludes","getArrayIndex","idx","nextIdx","item","prevIdx","getPositionIndex","node","previousSibling","getNodePath","_newOffsets","finds","getParentElement","el","temp","tempText","s","previous","removeItem","next","nextSibling","bind","reverse","getNodeFromPath","offsets","current","nodes","childNodes","isSameAttributes","b","style_a","style_b","compStyle","class_a","classList","class_b","reg","compClass","isEmptyLine","querySelector","children","isSpanWithoutAttr","isList","isListCell","isTable","isCell","isBreak","isAnchor","isMedia","isFigures","isNumber","getNumber","maxDec","number","Math","round","toFixed","getListChildren","recursionFunc","getListChildNodes","getElementDepth","depth","compareElements","aNode","bNode","ancestor","result","aIndex","bIndex","query","check","attr","split","getChildElement","last","childList","getEdgeChildNodes","first","firstChild","lastChild","sc","getOffset","wysiwygFrame","offsetLeft","offsetTop","offsetElement","parentElement","wysiwyg","offsetParent","left","top","scrollTop","getOverlapRangeAtIndex","aStart","aEnd","bStart","bEnd","overlap","changeTxt","txt","changeElement","newElement","outerHTML","innerHTML","replaceChild","setStyle","styleName","addClass","removeClass","trim","toggleClass","isImportantDisabled","hasAttribute","setDisabledButtons","disabled","buttonList","important","button","remove","removeChild","removeItemAllParents","stopParent","cc","parent","previousElementSibling","nextElementSibling","detachNestedList","baseNode","all","rNode","_deleteNestedList","rangeElement","cNodes","index","appendChild","rChildren","insertBefore","baseParent","sibling","liSibling","liParent","child","splitElement","offset","prev","bp","suffixIndex","newEl","splitText","after","data","depthEl","pElement","mergeSameTags","mergeNestedTags","nodePathArray","onlyText","inst","nodePathLen","Array","apply","Number","valueOf","depthIndex","_isIgnoreNodeChange","p","cDepth","spliceDepth","n","splice","childs","childLength","nLen","l","r","addOffset","textOffset","tempL","removeEmptyNode","notRemoveNode","forceDelete","_notTextNode","htmlRemoveWhiteSpace","html","htmlCompress","sortByDepth","des","t","f","sort","_isExcludeSelectionElement","_isMaintainedNode","_isSizeNode","fontSize","_disallowedTags","createTagsWhitelist","list","createTagsBlacklist","_consistencyCheckOfHTML","documentFragment","htmlCheckWhitelistRegExp","htmlCheckBlacklistRegExp","classNameFilter","removeTags","emptyTags","wrongList","withoutFormatCells","wrongTags","nrtag","fel","join","checkTags","cellChildren","j","tp","_setDefaultOptionStyle","options","defaultStyle","optionStyle","height","minHeight","maxHeight","position","width","minWidth","maxWidth","frame","editor","styleArr","_setIframeDocument","head","_setIframeCssTags","body","_editableClass","linkNames","iframeCSSFileName","wRegExp","tagString","CSSFileName","styleTag"],"sources":["E:/Programming/React/New folder (2)/dynamicArt/dynamic-article/node_modules/suneditor/src/lib/util.js"],"sourcesContent":["/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * @description utility function\r\n */\r\nconst util = {\r\n    _d: null,\r\n    _w: null,\r\n    isIE: null,\r\n    isIE_Edge: null,\r\n    isOSX_IOS: null,\r\n    isChromium: null,\r\n    isResizeObserverSupported: null, \r\n    _propertiesInit: function () {\r\n        if (this._d) return;\r\n        this._d =  document;\r\n        this._w = window;\r\n        this.isIE = navigator.userAgent.indexOf('Trident') > -1;\r\n        this.isIE_Edge = (navigator.userAgent.indexOf('Trident') > -1) || (navigator.appVersion.indexOf('Edge') > -1);\r\n        this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\r\n        this.isChromium = !!window.chrome;\r\n        this.isResizeObserverSupported = (typeof ResizeObserver === 'function');\r\n    },\r\n\r\n    _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',\r\n\r\n    /**\r\n     * @description HTML Reserved Word Converter.\r\n     * @param {String} contents \r\n     * @returns {String} HTML string\r\n     * @private\r\n     */\r\n    _HTMLConvertor: function (contents) {\r\n        const ec = {'&': '&amp;', '\\u00A0': '&nbsp;', '\\'': '&apos;', '\"': '&quot;', '<': '&lt;', '>': '&gt;'};\r\n        return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n     */\r\n    zeroWidthSpace: String.fromCharCode(8203),\r\n\r\n    /**\r\n     * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n     */\r\n    zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),\r\n\r\n    /**\r\n     * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n     */\r\n    onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),\r\n\r\n    fontValueMap: {\r\n        'xx-small': 1,\r\n        'x-small': 2,\r\n        'small': 3,\r\n        'medium': 4,\r\n        'large': 5,\r\n        'x-large': 6,\r\n        'xx-large': 7\r\n    },\r\n\r\n    /**\r\n     * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n     * @param {String|Node} text String value or Node\r\n     * @returns {Boolean}\r\n     */\r\n    onlyZeroWidthSpace: function (text) {\r\n        if (text === null || text === undefined) return false;\r\n        if (typeof text !== 'string') text = text.textContent;\r\n        return text === '' || this.onlyZeroWidthRegExp.test(text);\r\n    },\r\n\r\n    /**\r\n     * @description Gets XMLHttpRequest object\r\n     * @returns {XMLHttpRequest|ActiveXObject}\r\n     */\r\n    getXMLHttpRequest: function () {\r\n        /** IE */\r\n        if (this._w.ActiveXObject) {\r\n            try {\r\n                return new ActiveXObject('Msxml2.XMLHTTP');\r\n            } catch (e) {\r\n                try {\r\n                    return new ActiveXObject('Microsoft.XMLHTTP');\r\n                } catch (e1) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        /** netscape */\r\n        else if (this._w.XMLHttpRequest) {\r\n            return new XMLHttpRequest();\r\n        }\r\n        /** fail */\r\n        else {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Object.values\r\n     * @param {Object|null} obj Object parameter.\r\n     * @returns {Array}\r\n     */\r\n    getValues: function (obj) {\r\n        return !obj ? [] : this._w.Object.keys(obj).map(function (i) {\r\n            return obj[i];\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description Convert the CamelCase To the KebabCase.\r\n     * @param {String|Array} param [Camel string]\r\n     * @returns {String|Array}\r\n     */\r\n    camelToKebabCase: function (param) {\r\n        if (typeof param === 'string') {\r\n            return param.replace(/[A-Z]/g, function (letter) { return \"-\" + letter.toLowerCase(); });\r\n        } else {\r\n            return param.map(function(str) { return util.camelToKebabCase(str); });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Convert the KebabCase To the CamelCase.\r\n     * @param {String|Array} param [KebabCase string]\r\n     * @returns {String|Array}\r\n     */\r\n    kebabToCamelCase: function (param) {\r\n        if (typeof param === 'string') {\r\n            return param.replace(/-[a-zA-Z]/g, function (letter) { return letter.replace('-', '').toUpperCase(); });\r\n        } else {\r\n            return param.map(function(str) { return util.camelToKebabCase(str); });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Create Element node\r\n     * @param {String} elementName Element name\r\n     * @returns {Element}\r\n     */\r\n    createElement: function (elementName) {\r\n        return this._d.createElement(elementName);\r\n    },\r\n\r\n    /**\r\n     * @description Create text node\r\n     * @param {String} text text contents\r\n     * @returns {Node}\r\n     */\r\n    createTextNode: function (text) {\r\n        return this._d.createTextNode(text || '');\r\n    },\r\n\r\n    /**\r\n     * @description The editor checks tags by string.\r\n     * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n     * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n     * @param {String} contents HTML or Text string\r\n     * @returns {String}\r\n     */\r\n    HTMLEncoder: function (contents) {\r\n        const ec = {'<': '$lt;', '>': '$gt;'};\r\n        return contents.replace(/<|>/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description The editor checks tags by string.\r\n     * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n     * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n     * @param {String} contents HTML or Text string\r\n     * @returns {String}\r\n     */\r\n    HTMLDecoder: function (contents) {\r\n        const ec = {'$lt;': '<', '$gt;': '>'};\r\n        return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n     * @param {Object} obj Object\r\n     * @param {String} key obj.key\r\n     * @returns {Boolean}\r\n     */\r\n    hasOwn: function (obj, key) {\r\n        return this._hasOwn.call(obj, key);\r\n    },\r\n    _hasOwn: Object.prototype.hasOwnProperty,\r\n\r\n    /**\r\n     * @deprecated\r\n     * @description Get the the tag path of the arguments value\r\n     * If not found, return the first found value\r\n     * @param {Array} nameArray File name array\r\n     * @param {String} extension js, css\r\n     * @returns {String}\r\n     */\r\n    getIncludePath: function (nameArray, extension) {\r\n        let path = '';\r\n        const pathList = [];\r\n        const tagName = extension === 'js' ? 'script' : 'link';\r\n        const src = extension === 'js' ? 'src' : 'href';\r\n        \r\n        let fileName = '(?:';\r\n        for (let i = 0, len = nameArray.length; i < len; i++) {\r\n            fileName += nameArray[i] + (i < len - 1 ? '|' : ')');\r\n        }\r\n\r\n        const regExp = new this._w.RegExp('(^|.*[\\\\/])' + fileName + '(\\\\.[^\\\\/]+)?\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\r\n        const extRegExp = new this._w.RegExp('.+\\\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\r\n            \r\n        for (let c = this._d.getElementsByTagName(tagName), i = 0; i < c.length; i++) {\r\n            if (extRegExp.test(c[i][src])) {\r\n                pathList.push(c[i]);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < pathList.length; i++) {\r\n            let editorTag = pathList[i][src].match(regExp);\r\n            if (editorTag) {\r\n                path = editorTag[0];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';\r\n\r\n        -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\r\n\r\n        if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';\r\n\r\n        return path;\r\n    },\r\n\r\n    /**\r\n     * @deprecated\r\n     * @description Returns the CSS text that has been applied to the current page.\r\n     * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n     * @returns {String} Styles string\r\n     */\r\n    getPageStyle: function (doc) {\r\n        let cssText = '';\r\n        const sheets = (doc || this._d).styleSheets;\r\n        \r\n        for (let i = 0, len = sheets.length, rules; i < len; i++) {\r\n            try {\r\n                rules = sheets[i].cssRules;\r\n            } catch (e) {\r\n                continue;\r\n            }\r\n            \r\n            if (rules) {\r\n                for (let c = 0, cLen = rules.length; c < cLen; c++) {\r\n                    cssText += rules[c].cssText;\r\n                }\r\n            }\r\n        }\r\n\r\n        return cssText;\r\n    },\r\n\r\n    /**\r\n     * @description Get the argument iframe's document object\r\n     * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n     * @returns {Document}\r\n     */\r\n    getIframeDocument: function (iframe) {\r\n        let wDocument = iframe.contentWindow || iframe.contentDocument;\r\n        if (wDocument.document) wDocument = wDocument.document;\r\n        return wDocument;\r\n    },\r\n\r\n    /**\r\n     * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n     * @param {Element} element Element object\r\n     * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n     * @returns {String}\r\n     */\r\n    getAttributesToString: function (element, exceptAttrs) {\r\n        if (!element.attributes) return '';\r\n\r\n        const attrs = element.attributes;\r\n        let attrString = '';\r\n\r\n        for (let i = 0, len = attrs.length; i < len; i++) {\r\n            if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\r\n            attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\r\n        }\r\n\r\n        return attrString;\r\n    },\r\n\r\n    /**\r\n     * @descriptionGets Get the length in bytes of a string.\r\n     * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n     * @param {String} text String text\r\n     * @returns {Number}\r\n     */\r\n    getByteLength: function(text) {\r\n        if (!text || !text.toString) return 0;\r\n        text = text.toString();\r\n\r\n        const encoder = this._w.encodeURIComponent;\r\n        let cr, cl;\r\n        if (this.isIE_Edge) {\r\n            cl = this._w.unescape(encoder(text)).length;\r\n            cr = 0;\r\n\r\n            if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\r\n                cr = encoder(text).match(/(%0A|%0D)/gi).length;\r\n            }\r\n\r\n            return cl + cr;\r\n        } else {\r\n            cl = (new this._w.TextEncoder('utf-8').encode(text)).length;\r\n            cr = 0;\r\n\r\n            if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\r\n                cr = encoder(text).match(/(%0A|%0D)/gi).length;\r\n            }\r\n\r\n            return cl + cr;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isWysiwygDiv: function (element) {\r\n        return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the contenteditable property is false.\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isNonEditable: function (element) {\r\n        return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is a node related to the text style.\r\n     * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isTextStyleElement: function (element) {\r\n        return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the input element (INPUT, TEXTAREA)\r\n     * @param {Node} element The node to check\r\n     * @returns \r\n     */\r\n    isInputElement: function (element) {\r\n        return element && element.nodeType === 1 && /^(INPUT|TEXTAREA)$/i.test(element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__se__format__replace_xxx\")\r\n     * Format element also contain \"free format Element\"\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__replace_.+(\\\\s|$)|(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__se__format__range_xxx\")\r\n     * Range format element is wrap the \"format element\" and \"component\"\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isRangeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range_.+(\\\\s|$)'));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__se__format__range__closure_xxx\")\r\n     * Closure range format elements is included in the range format element.\r\n     *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n     * ※ You cannot exit this format with the Enter key or Backspace key.\r\n     * ※ Use it only in special cases. ([ex] format of table cells)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isClosureRangeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range__closure_.+(\\\\s|$)'));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the free format element. (PRE | class=\"__se__format__free_xxx\")\r\n     * Free format elements is included in the format element.\r\n     * Free format elements's line break is \"BR\" tag.\r\n     * ※ Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isFreeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the closure free format element. (class=\"__se__format__free__closure_xxx\")\r\n     * Closure free format elements is included in the free format element.\r\n     *  - Closure free format elements's line break is \"BR\" tag.\r\n     * ※ You cannot exit this format with the Enter key or Backspace key.\r\n     * ※ Use it only in special cases. ([ex] format of table cells)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isClosureFreeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && this.hasClass(element, '(\\\\s|^)__se__format__free__closure_.+(\\\\s|$)');\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"se-component\") and table, hr\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isComponent: function (element) {\r\n        return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description Checks for \"__se__uneditable\" in the class list.\r\n     * Components with class \"__se__uneditable\" cannot be modified.\r\n     * @param {Element} element The element to check\r\n     * @returns {Boolean}\r\n     */\r\n    isUneditableComponent: function (element) {\r\n        return element && this.hasClass(element, '__se__uneditable');\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the component [img, iframe] cover(class=\"se-component\")\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isMediaComponent: function (element) {\r\n        return element && /se-component/.test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the not checking node. (class=\"katex\", \"__se__tag\")\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isNotCheckingNode: function (element) {\r\n        return element && /katex|__se__tag/.test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isRangeFormatElement(element)) element.firstElementChild;\r\n            if (this.isFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getRangeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getFreeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isFreeFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getClosureFreeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description Add style and className of copyEl to originEl\r\n     * @param {Element} originEl Origin element\r\n     * @param {Element} copyEl Element to copy\r\n     * @param {Array|null} blacklist Blacklist array(LowerCase)\r\n     */\r\n    copyTagAttributes: function (originEl, copyEl, blacklist) {\r\n        if (copyEl.style.cssText) {\r\n            const copyStyles = copyEl.style;\r\n            for (let i = 0, len = copyStyles.length; i < len; i++) {\r\n                originEl.style[copyStyles[i]] = copyStyles[copyStyles[i]];\r\n            }\r\n        }\r\n\r\n        const attrs = copyEl.attributes;\r\n        for (let i = 0, len = attrs.length, name; i < len; i++) {\r\n            name = attrs[i].name.toLowerCase();\r\n            if ((blacklist && blacklist.indexOf(name) > -1) || !attrs[i].value) originEl.removeAttribute(name);\r\n            else if (name !== 'style') originEl.setAttribute(attrs[i].name, attrs[i].value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__se__format__\" class\r\n     * @param {Element} originEl Origin element\r\n     * @param {Element} copyEl Element to copy\r\n     */\r\n    copyFormatAttributes: function (originEl, copyEl) {\r\n        copyEl = copyEl.cloneNode(false);\r\n        copyEl.className = copyEl.className.replace(/(\\s|^)__se__format__[^\\s]+/g, '');\r\n        this.copyTagAttributes(originEl, copyEl);\r\n    },\r\n\r\n    /**\r\n     * @description Get the item from the array that matches the condition.\r\n     * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n     * @param {Function|null} validation Conditional function\r\n     * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n     * If false, returns only one item that meet the criteria otherwise return null.\r\n     * @returns {Array|Node|null}\r\n     */\r\n    getArrayItem: function (array, validation, multi) {\r\n        if (!array || array.length === 0) return null;\r\n\r\n        validation = validation || function () { return true; };\r\n        const arr = [];\r\n        \r\n        for (let i = 0, len = array.length, a; i < len; i++) {\r\n            a = array[i];\r\n            if (validation(a)) {\r\n                if (!multi) return a;\r\n                else arr.push(a);\r\n            }\r\n        }\r\n\r\n        return !multi ? null : arr;\r\n    },\r\n\r\n    /**\r\n     * @description Check if an array contains an element \r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} element The element to check for\r\n     * @returns {Boolean}\r\n     */\r\n    arrayIncludes: function(array, element) {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (array[i] === element) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * @description Get the index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} element The element to find index\r\n     * @returns {Number}\r\n     */\r\n    getArrayIndex: function (array, element) {\r\n        let idx = -1;\r\n        for (let i = 0, len = array.length; i < len; i++) {\r\n            if (array[i] === element) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return idx;\r\n    },\r\n\r\n    /**\r\n     * @description Get the next index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} item The element to find index\r\n     * @returns {Number}\r\n     */\r\n    nextIdx: function (array, item) {\r\n        let idx = this.getArrayIndex(array, item);\r\n        if (idx === -1) return -1;\r\n        return idx + 1;\r\n    },\r\n\r\n    /**\r\n     * @description Get the previous index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array Element array\r\n     * @param {Node} item The element to find index\r\n     * @returns {Number}\r\n     */\r\n    prevIdx: function (array, item) {\r\n        let idx = this.getArrayIndex(array, item);\r\n        if (idx === -1) return -1;\r\n        return idx - 1;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the index compared to other sibling nodes.\r\n     * @param {Node} node The Node to find index\r\n     * @returns {Number}\r\n     */\r\n    getPositionIndex: function (node) {\r\n        let idx = 0;\r\n        while ((node = node.previousSibling)) {\r\n            idx += 1;\r\n        }\r\n        return idx;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n     * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n     * @param {Node} node The Node to find position path\r\n     * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n     * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n     * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n     * Do not use unless absolutely necessary.\r\n     * @returns {Array}\r\n     */\r\n    getNodePath: function (node, parentNode, _newOffsets) {\r\n        const path = [];\r\n        let finds = true;\r\n\r\n        this.getParentElement(node, function (el) {\r\n            if (el === parentNode) finds = false;\r\n            if (finds && !this.isWysiwygDiv(el)) {\r\n                // merge text nodes\r\n                if (_newOffsets && el.nodeType === 3) {\r\n                    let temp = null, tempText = null;\r\n                    _newOffsets.s = _newOffsets.e = 0;\r\n\r\n                    let previous = el.previousSibling;\r\n                    while (previous && previous.nodeType === 3) {\r\n                        tempText = previous.textContent.replace(this.zeroWidthRegExp, '');\r\n                        _newOffsets.s += tempText.length;\r\n                        el.textContent = tempText + el.textContent;\r\n                        temp = previous;\r\n                        previous = previous.previousSibling;\r\n                        this.removeItem(temp);\r\n                    }\r\n\r\n                    let next = el.nextSibling;\r\n                    while (next && next.nodeType === 3) {\r\n                        tempText = next.textContent.replace(this.zeroWidthRegExp, '');\r\n                        _newOffsets.e += tempText.length;\r\n                        el.textContent += tempText;\r\n                        temp = next;\r\n                        next = next.nextSibling;\r\n                        this.removeItem(temp);\r\n                    }\r\n                }\r\n\r\n                // index push\r\n                path.push(el);\r\n            }\r\n            return false;\r\n        }.bind(this));\r\n        \r\n        return path.map(this.getPositionIndex).reverse();\r\n    },\r\n\r\n    /**\r\n     * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n     * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n     * @param {Node} parentNode Base parent element\r\n     * @returns {Node}\r\n     */\r\n    getNodeFromPath: function (offsets, parentNode) {\r\n        let current = parentNode;\r\n        let nodes;\r\n\r\n        for (let i = 0, len = offsets.length; i < len; i++) {\r\n            nodes = current.childNodes;\r\n            if (nodes.length === 0) break;\r\n            if (nodes.length <= offsets[i]) {\r\n                current = nodes[nodes.length - 1];\r\n            } else {\r\n                current = nodes[offsets[i]];\r\n            }\r\n        }\r\n\r\n        return current;\r\n    },\r\n\r\n    /**\r\n     * @description Compares the style and class for equal values.\r\n     * Returns true if both are text nodes.\r\n     * @param {Node} a Node to compare\r\n     * @param {Node} b Node to compare\r\n     * @returns {Boolean}\r\n     */\r\n    isSameAttributes: function (a, b) {\r\n        if (a.nodeType === 3 && b.nodeType === 3) return true;\r\n        if (a.nodeType === 3 || b.nodeType === 3) return false;\r\n\r\n        const style_a = a.style;\r\n        const style_b = b.style;\r\n        let compStyle = 0;\r\n\r\n        for (let i = 0, len = style_a.length; i < len; i++) {\r\n            if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\r\n        }\r\n\r\n        const class_a = a.classList;\r\n        const class_b = b.classList;\r\n        const reg = this._w.RegExp;\r\n        let compClass = 0;\r\n\r\n        for (let i = 0, len = class_a.length; i < len; i++) {\r\n            if (reg('(\\s|^)' + class_a[i] + '(\\s|$)').test(class_b.value)) compClass++;\r\n        }\r\n\r\n        return (compStyle === style_b.length && compStyle === style_a.length) && (compClass === class_b.length && compClass === class_a.length);\r\n    },\r\n\r\n    /**\r\n     * @description Check the line element(util.isFormatElement) is empty.\r\n     * @param {Element} element Format element node\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyLine: function (element) {\r\n        return !element || !element.parentNode || (!element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && element.children.length === 0 && this.onlyZeroWidthSpace(element.textContent));\r\n    },\r\n\r\n    /**\r\n     * @description Check the span's attributes are empty.\r\n     * @param {Element|null} element Element node\r\n     * @returns {Boolean}\r\n     */\r\n    isSpanWithoutAttr: function (element) {\r\n        return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a list (ol, ul)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isList: function (node) {\r\n        return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a list cell (li)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isListCell: function (node) {\r\n        return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isTable: function (node) {\r\n        return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a table cell (td, th)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isCell: function (node) {\r\n        return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a break node (BR)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isBreak: function (node) {\r\n        return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n\r\n    /**\r\n     * @description Check the node is a anchor node (A)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isAnchor: function (node) {\r\n        return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isMedia: function (node) {\r\n        return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a figure tag or util.isMedia()\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isFigures: function (node) {\r\n        return node && (this.isMedia(node) || /^(FIGURE)$/i.test(typeof node === 'string' ? node : node.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description Checks for numeric (with decimal point).\r\n     * @param {String|Number} text Text string or number\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber: function (text) {\r\n        return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + '');\r\n    },\r\n\r\n    /**\r\n     * @description Get a number.\r\n     * @param {String|Number} text Text string or number\r\n     * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n     * @returns {Number}\r\n     */\r\n    getNumber: function (text, maxDec) {\r\n        if (!text) return 0;\r\n        \r\n        let number = (text + '').match(/-?\\d+(\\.\\d+)?/);\r\n        if (!number || !number[0]) return 0;\r\n\r\n        number = number[0];\r\n        return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\r\n    },\r\n\r\n    /**\r\n     * @description Get all \"children\" of the argument value element (Without text nodes)\r\n     * @param {Element} element element to get child node\r\n     * @param {Function|null} validation Conditional function\r\n     * @returns {Array}\r\n     */\r\n    getListChildren: function (element, validation) {\r\n        const children = [];\r\n        if (!element || !element.children || element.children.length === 0) return children;\r\n\r\n        validation = validation || function () { return true; };\r\n\r\n        (function recursionFunc(current) {\r\n            if (element !== current && validation(current)) {\r\n                children.push(current);\r\n            }\r\n\r\n            if (!!current.children) {\r\n                for (let i = 0, len = current.children.length; i < len; i++) {\r\n                    recursionFunc(current.children[i]);\r\n                }\r\n            }\r\n        })(element);\r\n\r\n        return children;\r\n    },\r\n\r\n    /**\r\n     * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n     * @param {Node} element element to get child node\r\n     * @param {Function|null} validation Conditional function\r\n     * @returns {Array}\r\n     */\r\n    getListChildNodes: function (element, validation) {\r\n        const children = [];\r\n        if (!element || element.childNodes.length === 0) return children;\r\n\r\n        validation = validation || function () { return true; };\r\n\r\n        (function recursionFunc(current) {\r\n            if (element !== current && validation(current)) {\r\n                children.push(current);\r\n            }\r\n\r\n            for (let i = 0, len = current.childNodes.length; i < len; i++) {\r\n                recursionFunc(current.childNodes[i]);\r\n            }\r\n        })(element);\r\n\r\n        return children;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the number of parents nodes.\r\n     * \"0\" when the parent node is the WYSIWYG area.\r\n     * \"-1\" when the element argument is the WYSIWYG area.\r\n     * @param {Node} element The element to check\r\n     * @returns {Number}\r\n     */\r\n    getElementDepth: function (element) {\r\n        if (!element || this.isWysiwygDiv(element)) return -1;\r\n\r\n        let depth = 0;\r\n        element = element.parentNode;\r\n\r\n        while (element && !this.isWysiwygDiv(element)) {\r\n            depth += 1;\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return depth;\r\n    },\r\n\r\n    /**\r\n     * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n     * @param {Node} a Node to compare.\r\n     * @param {Node} b Node to compare.\r\n     * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n     */\r\n    compareElements: function (a, b) {\r\n        let aNode = a, bNode = b;\r\n        while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\r\n            aNode = aNode.parentNode;\r\n            bNode = bNode.parentNode;\r\n        }\r\n\r\n        if (!aNode || !bNode) return { ancestor: null, a: a, b: b, result: 0 };\r\n\r\n        const children = aNode.parentNode.childNodes;\r\n        const aIndex = this.getArrayIndex(children, aNode);\r\n        const bIndex = this.getArrayIndex(children, bNode);\r\n\r\n        return {\r\n            ancestor: aNode.parentNode,\r\n            a: aNode,\r\n            b: bNode,\r\n            result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description Get the parent element of the argument value.\r\n     * A tag that satisfies the query condition is imported.\r\n     * Returns null if not found.\r\n     * @param {Node} element Reference element\r\n     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n     * Not use it like jquery.\r\n     * Only one condition can be entered at a time.\r\n     * @returns {Element|null}\r\n     */\r\n    getParentElement: function (element, query) {\r\n        let check;\r\n\r\n        if (typeof query === 'function') {\r\n            check = query;\r\n        } else {\r\n            let attr;\r\n            if (/^\\./.test(query)) {\r\n                attr = 'className';\r\n                query = query.split('.')[1];\r\n            } else if (/^#/.test(query)) {\r\n                attr = 'id';\r\n                query = '^' + query.split('#')[1] + '$';\r\n            } else if (/^:/.test(query)) {\r\n                attr = 'name';\r\n                query = '^' + query.split(':')[1] + '$';\r\n            } else {\r\n                attr = 'nodeName';\r\n                query = '^' + query + '$';\r\n            }\r\n\r\n            const regExp = new this._w.RegExp(query, 'i');\r\n            check = function (el) {\r\n                return regExp.test(el[attr]);\r\n            };\r\n        }\r\n\r\n        while (element && !check(element)) {\r\n            if (this.isWysiwygDiv(element)) {\r\n                return null;\r\n            }\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return element;\r\n    },\r\n\r\n    /**\r\n     * @description Get the child element of the argument value.\r\n     * A tag that satisfies the query condition is imported.\r\n     * Returns null if not found.\r\n     * @param {Node} element Reference element\r\n     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n     * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n     * Not use it like jquery.\r\n     * Only one condition can be entered at a time.\r\n     * @returns {Element|null}\r\n     */\r\n    getChildElement: function (element, query, last) {\r\n        let check;\r\n\r\n        if (typeof query === 'function') {\r\n            check = query;\r\n        } else {\r\n            let attr;\r\n            if (/^\\./.test(query)) {\r\n                attr = 'className';\r\n                query = query.split('.')[1];\r\n            } else if (/^#/.test(query)) {\r\n                attr = 'id';\r\n                query = '^' + query.split('#')[1] + '$';\r\n            } else if (/^:/.test(query)) {\r\n                attr = 'name';\r\n                query = '^' + query.split(':')[1] + '$';\r\n            } else {\r\n                attr = 'nodeName';\r\n                query = '^' + (query === 'text' ? '#' + query : query) + '$';\r\n            }\r\n\r\n            const regExp = new this._w.RegExp(query, 'i');\r\n            check = function (el) {\r\n                return regExp.test(el[attr]);\r\n            };\r\n        }\r\n\r\n        const childList = this.getListChildNodes(element, function (current) {\r\n            return check(current);\r\n        });\r\n\r\n        return childList[last ? childList.length - 1 : 0];\r\n    },\r\n\r\n    /**\r\n     * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n     * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n     * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n     * { sc: \"first\", ec: \"last\" }\r\n     * @param {Node} first First element\r\n     * @param {Node|null} last Last element\r\n     * @returns {Object}\r\n     */\r\n    getEdgeChildNodes: function (first, last) {\r\n        if (!first) return;\r\n        if (!last) last = first;\r\n\r\n        while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;\r\n        while (last && last.nodeType === 1 && last.childNodes.length > 0 &&  !this.isBreak(last)) last = last.lastChild;\r\n\r\n        return {\r\n            sc: first,\r\n            ec: last || first\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n     * @param {Node} element Target node\r\n     * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n     * @returns {Object}\r\n     */\r\n    getOffset: function (element, wysiwygFrame) {\r\n        let offsetLeft = 0;\r\n        let offsetTop = 0;\r\n        let offsetElement = element.nodeType === 3 ? element.parentElement : element;\r\n        const wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\r\n\r\n        while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {\r\n            offsetLeft += offsetElement.offsetLeft;\r\n            offsetTop += offsetElement.offsetTop;\r\n            offsetElement = offsetElement.offsetParent;\r\n        }\r\n\r\n        const iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\r\n\r\n        return {\r\n            left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\r\n            top: (offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0)) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n     * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n     * @param {Number} aStart Start index of \"a\"\r\n     * @param {Number} aEnd End index of \"a\"\r\n     * @param {Number} bStart Start index of \"b\"\r\n     * @param {Number} bEnd Start index of \"b\"\r\n     * @returns {Number}\r\n     */\r\n    getOverlapRangeAtIndex: function (aStart, aEnd, bStart, bEnd) {\r\n        if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\r\n\r\n        const overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\r\n        return (overlap < 0 ? overlap * -1 : overlap) + 1;\r\n    },\r\n\r\n    /**\r\n     * @description Set the text content value of the argument value element\r\n     * @param {Node} element Element to replace text content\r\n     * @param {String} txt Text to be applied\r\n     */\r\n    changeTxt: function (element, txt) {\r\n        if (!element || !txt) return;\r\n        element.textContent = txt;\r\n    },\r\n\r\n    /**\r\n     * @description Replace element\r\n     * @param {Element} element Target element\r\n     * @param {String|Element} newElement String or element of the new element to apply\r\n     */\r\n    changeElement: function (element, newElement) {\r\n        if (typeof newElement === 'string') {\r\n            if (element.outerHTML) {\r\n                element.outerHTML = newElement;\r\n            } else {\r\n                const doc = this.createElement('DIV');\r\n                doc.innerHTML = newElement;\r\n                newElement = doc.firstChild;\r\n                element.parentNode.replaceChild(newElement, element);\r\n            }\r\n        } else if (newElement.nodeType === 1) {\r\n            element.parentNode.replaceChild(newElement, element);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Set style, if all styles are deleted, the style properties are deleted.\r\n     * @param {Element} element Element to set style\r\n     * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n     * @param {String|Number} value Style value\r\n     */\r\n    setStyle: function (element, styleName, value) {\r\n        element.style[styleName] = value;\r\n\r\n        if (!value && !element.style.cssText) {\r\n            element.removeAttribute('style');\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Determine whether any of the matched elements are assigned the given class\r\n     * @param {Element} element Elements to search class name\r\n     * @param {String} className Class name to search for\r\n     * @returns {Boolean}\r\n     */\r\n    hasClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        return (new this._w.RegExp(className)).test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description Append the className value of the argument value element\r\n     * @param {Element} element Elements to add class name\r\n     * @param {String} className Class name to be add\r\n     */\r\n    addClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        if (check.test(element.className)) return;\r\n\r\n        element.className += (element.className.length > 0 ? ' ' : '') + className;\r\n    },\r\n\r\n    /**\r\n     * @description Delete the className value of the argument value element\r\n     * @param {Element} element Elements to remove class name\r\n     * @param {String} className Class name to be remove\r\n     */\r\n    removeClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        element.className = element.className.replace(check, ' ').trim();\r\n\r\n        if (!element.className.trim()) element.removeAttribute('class');\r\n    },\r\n\r\n    /**\r\n     * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n     * @param {Element} element Elements to replace class name\r\n     * @param {String} className Class name to be change\r\n     * @returns {Boolean|undefined}\r\n     */\r\n    toggleClass: function (element, className) {\r\n        if (!element) return;\r\n        let result = false;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        if (check.test(element.className)) {\r\n            element.className = element.className.replace(check, ' ').trim();\r\n        } else {\r\n            element.className += ' ' + className;\r\n            result = true;\r\n        }\r\n\r\n        if (!element.className.trim()) element.removeAttribute('class');\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * @description Checks if element can't be easily enabled\r\n     * @param {Element} element Element to check for\r\n     */\r\n    isImportantDisabled: function (element) {\r\n        return element.hasAttribute('data-important-disabled');\r\n    },\r\n\r\n    /**\r\n     * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n     * core.codeViewDisabledButtons (An array of buttons whose class name is not \"se-code-view-enabled\")\r\n     * core.resizingDisabledButtons (An array of buttons whose class name is not \"se-resizing-enabled\")\r\n     * @param {Boolean} disabled Disabled value\r\n     * @param {Array|HTMLCollection|NodeList} buttonList Button array\r\n     * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)\r\n     */\r\n    setDisabledButtons: function (disabled, buttonList, important) {\r\n        for (let i = 0, len = buttonList.length; i < len; i++) {\r\n            let button = buttonList[i];\r\n            if (important || !this.isImportantDisabled(button)) button.disabled = disabled;\r\n            if (important) {\r\n                if (disabled) { \r\n                    button.setAttribute('data-important-disabled', '');\r\n                } else {\r\n                    button.removeAttribute('data-important-disabled');\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Delete argumenu value element\r\n     * @param {Node} item Node to be remove\r\n     */\r\n    removeItem: function (item) {\r\n        if (!item) return;\r\n\r\n        if(typeof item.remove === 'function') item.remove();\r\n        else if (item.parentNode) item.parentNode.removeChild(item);\r\n    },\r\n\r\n    /**\r\n     * @description Delete all parent nodes that match the condition.\r\n     * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n     * @param {Node} item Node to be remove\r\n     * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n     * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n     * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n     */\r\n    removeItemAllParents: function (item, validation, stopParent) {\r\n        if (!item) return null;\r\n        let cc = null;\r\n        if (!validation) {\r\n            validation = function (current) {\r\n                if (current === stopParent || this.isComponent(current)) return false;\r\n                const text = current.textContent.trim();\r\n                return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\r\n            }.bind(this);\r\n        }\r\n\r\n        (function recursionFunc (element) {\r\n            if (!util.isWysiwygDiv(element)) {\r\n                const parent = element.parentNode;\r\n                if (parent && validation(element)) {\r\n                    cc = {\r\n                        sc: element.previousElementSibling,\r\n                        ec: element.nextElementSibling\r\n                    };\r\n                    util.removeItem(element);\r\n                    recursionFunc(parent);\r\n                }\r\n            }\r\n        }(item));\r\n\r\n        return cc;\r\n    },\r\n\r\n    /**\r\n     * @description Detach Nested all nested lists under the \"baseNode\".\r\n     * Returns a list with nested removed.\r\n     * @param {Node} baseNode Element on which to base.\r\n     * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n     * @returns {Element}\r\n     */\r\n    detachNestedList: function (baseNode, all) {\r\n        const rNode = this._deleteNestedList(baseNode);\r\n        let rangeElement, cNodes;\r\n\r\n        if (rNode) {\r\n            rangeElement = rNode.cloneNode(false);\r\n            cNodes = rNode.childNodes;\r\n            const index = this.getPositionIndex(baseNode);\r\n            while (cNodes[index]) {\r\n                rangeElement.appendChild(cNodes[index]);\r\n            }\r\n        } else {\r\n            rangeElement = baseNode;\r\n        }\r\n        \r\n        let rChildren;\r\n        if (!all) {\r\n            const depth = this.getElementDepth(baseNode) + 2;\r\n            rChildren = this.getListChildren(baseNode, function (current) { return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth; }.bind(this));\r\n        } else {\r\n            rChildren = this.getListChildren(rangeElement, function (current) { return this.isListCell(current) && !current.previousElementSibling; }.bind(this));\r\n        }\r\n\r\n        for (let i = 0, len = rChildren.length; i < len; i++) {\r\n            this._deleteNestedList(rChildren[i]);\r\n        }\r\n        \r\n        if (rNode) {\r\n            rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\r\n            if (cNodes && cNodes.length === 0) this.removeItem(rNode);\r\n        }\r\n\r\n        return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\r\n    },\r\n\r\n    /**\r\n     * @description Sub function of util.detachNestedList method.\r\n     * @private\r\n     */\r\n    _deleteNestedList: function (baseNode) {\r\n        const baseParent = baseNode.parentNode;\r\n        let sibling = baseParent;\r\n        let parent = sibling.parentNode;\r\n        let liSibling, liParent, child, index, c;\r\n        \r\n        while (this.isListCell(parent)) {\r\n            index = this.getPositionIndex(baseNode);\r\n            liSibling = parent.nextElementSibling;\r\n            liParent = parent.parentNode;\r\n            child = sibling;\r\n            while(child) {\r\n                sibling = sibling.nextSibling;\r\n                if (this.isList(child)) {\r\n                    c = child.childNodes;\r\n                    while (c[index]) {\r\n                        liParent.insertBefore(c[index], liSibling);\r\n                    }\r\n                    if (c.length === 0) this.removeItem(child);\r\n                } else {\r\n                    liParent.appendChild(child);\r\n                }\r\n                child = sibling;\r\n            }\r\n            sibling = liParent;\r\n            parent = liParent.parentNode;\r\n        }\r\n\r\n        if (baseParent.children.length === 0) this.removeItem(baseParent);\r\n\r\n        return liParent;\r\n    },\r\n\r\n    /**\r\n     * @description Split all tags based on \"baseNode\"\r\n     * Returns the last element of the splited tag.\r\n     * @param {Node} baseNode Element or text node on which to base\r\n     * @param {Number|Node|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n     * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n     * @returns {Element}\r\n     */\r\n    splitElement: function (baseNode, offset, depth) {\r\n        if (this.isWysiwygDiv(baseNode)) return baseNode;\r\n\r\n        if (offset && !this.isNumber(offset)) {\r\n            const children =  baseNode.childNodes;\r\n            let index = this.getPositionIndex(offset);\r\n            const prev = baseNode.cloneNode(false);\r\n            const next = baseNode.cloneNode(false);\r\n            for (let i = 0, len = children.length; i < len; i++) {\r\n                if (i < index) prev.appendChild(children[i]);\r\n                else if (i > index) next.appendChild(children[i]);\r\n                else continue;\r\n                i--;\r\n                len--;\r\n                index--;\r\n            }\r\n\r\n            if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);\r\n            if (next.childNodes.length > 0) baseNode.parentNode.insertBefore(next, baseNode.nextElementSibling);\r\n\r\n            return baseNode;\r\n        }\r\n\r\n        const bp = baseNode.parentNode;\r\n        let index = 0;\r\n        let suffixIndex = 1;\r\n        let next = true;\r\n        let newEl, children, temp;\r\n        if (!depth || depth < 0) depth = 0;\r\n\r\n        if (baseNode.nodeType === 3) {\r\n            index = this.getPositionIndex(baseNode);\r\n            if (offset >= 0 && baseNode.length !== offset) {\r\n                baseNode.splitText(offset);\r\n                const after = this.getNodeFromPath([index + 1], bp);\r\n                if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\r\n            }\r\n        } else if (baseNode.nodeType === 1) {\r\n            if (offset === 0) {\r\n                while (baseNode.firstChild) {\r\n                    baseNode = baseNode.firstChild;\r\n                }\r\n                if (baseNode.nodeType === 3) {\r\n                    const after = this.createTextNode(this.zeroWidthSpace);\r\n                    baseNode.parentNode.insertBefore(after, baseNode);\r\n                    baseNode = after;\r\n                }\r\n            }\r\n            if (!baseNode.previousSibling) {\r\n                if (this.getElementDepth(baseNode) === depth) next = false;\r\n            } else {\r\n                baseNode = baseNode.previousSibling;\r\n            }\r\n        }\r\n\r\n        if (baseNode.nodeType === 1) suffixIndex = 0;\r\n        let depthEl = baseNode;\r\n        while (this.getElementDepth(depthEl) > depth) {\r\n            index = this.getPositionIndex(depthEl) + suffixIndex;\r\n            depthEl = depthEl.parentNode;\r\n\r\n            temp = newEl;\r\n            newEl = depthEl.cloneNode(false);\r\n            children = depthEl.childNodes;\r\n\r\n            if (temp) {\r\n                if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\r\n                    newEl.innerHTML = temp.firstElementChild.innerHTML;\r\n                    util.removeItem(temp.firstElementChild);\r\n                    if (temp.children.length > 0) newEl.appendChild(temp);\r\n                } else {\r\n                    newEl.appendChild(temp);\r\n                }\r\n            }\r\n\r\n            while (children[index]) {\r\n                newEl.appendChild(children[index]);\r\n            }\r\n        }\r\n\r\n        if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';\r\n\r\n        const pElement = depthEl.parentNode;\r\n        if (next) depthEl = depthEl.nextSibling;\r\n        if (!newEl) return depthEl;\r\n\r\n        this.mergeSameTags(newEl, null, false);\r\n        this.mergeNestedTags(newEl, function (current) { return this.isList(current); }.bind(this));\r\n        \r\n        if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);\r\n        else newEl = depthEl;\r\n\r\n        if (this.isListCell(newEl) && newEl.children && this.isList(newEl.children[0])) {\r\n            newEl.insertBefore(this.createElement('BR'), newEl.children[0]);\r\n        }\r\n\r\n        if (bp.childNodes.length === 0) this.removeItem(bp);\r\n\r\n        return newEl;\r\n    },\r\n\r\n    /**\r\n     * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n     * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n     * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n     * @param {Element} element Element\r\n     * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n     * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n     * @returns {Array} [offset, ..]\r\n     */\r\n    mergeSameTags: function (element, nodePathArray, onlyText) {\r\n        const inst = this;\r\n        const nodePathLen = nodePathArray ? nodePathArray.length : 0;\r\n        let offsets = null;\r\n        \r\n        if (nodePathLen) {\r\n            offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\r\n        }\r\n\r\n        (function recursionFunc(current, depth, depthIndex) {\r\n            const children = current.childNodes;\r\n            \r\n            for (let i = 0, len = children.length, child, next; i < len; i++) {\r\n                child = children[i];\r\n                next = children[i + 1];\r\n                if (!child) break;\r\n                if((onlyText && inst._isIgnoreNodeChange(child)) || (!onlyText && (inst.isTable(child) || inst.isListCell(child) || (inst.isFormatElement(child) && !inst.isFreeFormatElement(child))))) {\r\n                    if (inst.isTable(child) || inst.isListCell(child)) {\r\n                        recursionFunc(child, depth + 1, i);\r\n                    }\r\n                    continue;\r\n                }\r\n                if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\r\n                    // update nodePath\r\n                    if (nodePathLen) {\r\n                        let path, c, p, cDepth, spliceDepth;\r\n                        for (let n = 0; n < nodePathLen; n++) {\r\n                            path = nodePathArray[n];\r\n                            if (path && path[depth] === i) {\r\n                                c = child, p = current, cDepth = depth, spliceDepth = true;\r\n                                while (cDepth >= 0) {\r\n                                    if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\r\n                                        spliceDepth = false;\r\n                                        break;\r\n                                    }\r\n                                    c = child.parentNode;\r\n                                    p = c.parentNode;\r\n                                    cDepth--;\r\n                                }\r\n                                if (spliceDepth) {\r\n                                    path.splice(depth, 1);\r\n                                    path[depth] = i;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // merge tag\r\n                    inst.copyTagAttributes(child, current);\r\n                    current.parentNode.insertBefore(child, current);\r\n                    inst.removeItem(current);\r\n                }\r\n                if (!next) {\r\n                    if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\r\n                    break;\r\n                }\r\n\r\n                if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\r\n                    const childs = child.childNodes;\r\n                    let childLength = 0;\r\n                    for (let n = 0, nLen = childs.length; n < nLen; n++) {\r\n                        if (childs[n].textContent.length > 0) childLength++;\r\n                    }\r\n\r\n                    const l = child.lastChild;\r\n                    const r = next.firstChild;\r\n                    let addOffset = 0;\r\n                    if (l && r) {\r\n                        const textOffset = l.nodeType === 3 && r.nodeType === 3;\r\n                        addOffset = l.textContent.length;\r\n                        let tempL = l.previousSibling;\r\n                        while(tempL && tempL.nodeType === 3) {\r\n                            addOffset += tempL.textContent.length;\r\n                            tempL = tempL.previousSibling;\r\n                        }\r\n\r\n                        if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\r\n\r\n                        if (nodePathLen) {\r\n                            let path = null;\r\n                            for (let n = 0; n < nodePathLen; n++) {\r\n                                path = nodePathArray[n];\r\n                                if (path && path[depth] > i) {\r\n                                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;\r\n    \r\n                                    path[depth] -= 1;\r\n                                    if (path[depth + 1] >= 0 && path[depth] === i) {\r\n                                        path[depth + 1] += childLength;\r\n                                        if (textOffset) {\r\n                                            if (l && l.nodeType === 3 && r && r.nodeType === 3) {\r\n                                                offsets[n] += addOffset;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (child.nodeType === 3) {\r\n                        addOffset = child.textContent.length;\r\n                        child.textContent += next.textContent;\r\n                        if (nodePathLen) {\r\n                            let path = null;\r\n                            for (let n = 0; n < nodePathLen; n++) {\r\n                                path = nodePathArray[n];\r\n                                if (path && path[depth] > i) {\r\n                                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;\r\n    \r\n                                    path[depth] -= 1;\r\n                                    if (path[depth + 1] >= 0 && path[depth] === i) {\r\n                                        path[depth + 1] += childLength;\r\n                                        offsets[n] += addOffset;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        child.innerHTML += next.innerHTML;\r\n                    }\r\n                    \r\n                    inst.removeItem(next);\r\n                    i--;\r\n                } else if (child.nodeType === 1) {\r\n                    recursionFunc(child, depth + 1, i);\r\n                }\r\n            }\r\n        })(element, 0, 0);\r\n\r\n        return offsets;\r\n    },\r\n\r\n    /**\r\n     * @description Remove nested tags without other child nodes.\r\n     * @param {Element} element Element object\r\n     * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n     */\r\n    mergeNestedTags: function (element, validation) {\r\n        if (typeof validation === 'string') {\r\n            validation = function (current) { return this.test(current.tagName); }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));\r\n        } else if (typeof validation !== 'function') {\r\n            validation = function () { return true; };\r\n        }\r\n        \r\n        (function recursionFunc(current) {\r\n            let children = current.children;\r\n            if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\r\n                const temp = children[0];\r\n                children = temp.children;\r\n                while (children[0]) {\r\n                    current.appendChild(children[0]);\r\n                }\r\n                current.removeChild(temp);\r\n            }\r\n\r\n            for (let i = 0, len = current.children.length; i < len; i++) {\r\n                recursionFunc(current.children[i]);\r\n            }\r\n        })(element);\r\n    },\r\n\r\n    /**\r\n     * @description Delete a empty child node of argument element.\r\n     * @param {Element} element Element node\r\n     * @param {Node|null} notRemoveNode Do not remove node\r\n     * @param {boolean} forceDelete When all child nodes are deleted, the parent node is also deleted.\r\n     */\r\n    removeEmptyNode: function (element, notRemoveNode, forceDelete) {\r\n        const inst = this;\r\n\r\n        if (notRemoveNode) {\r\n            notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\r\n                return element === current.parentElement;\r\n            });\r\n        }\r\n        \r\n        (function recursionFunc(current) {\r\n            if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\r\n            if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\r\n                if (current.parentNode) {\r\n                    current.parentNode.removeChild(current);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                const children = current.children;\r\n                for (let i = 0, len = children.length, r = 0; i < len; i++) {\r\n                    if (!children[i + r] || inst.isComponent(children[i + r])) continue;\r\n                    r += recursionFunc(children[i + r]);\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        })(element);\r\n\r\n        if (element.childNodes.length === 0) {\r\n            if (forceDelete) {\r\n                this.removeItem(element);\r\n            } else {\r\n                element.innerHTML = '<br>';\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Remove whitespace between tags in HTML string.\r\n     * @param {String} html HTML string\r\n     * @returns {String}\r\n     */\r\n    htmlRemoveWhiteSpace: function (html) {\r\n        if (!html) return '';\r\n        return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\\s+(?=<)/ig, function (m) { return m.replace(/\\n/g, '').replace(/\\s+/, ' '); });\r\n    },\r\n\r\n    /**\r\n\t * @description HTML code compression\r\n\t * @param {string} html HTML string\r\n\t * @returns {string} HTML string\r\n\t */\r\n\thtmlCompress: function (html) {\r\n\t\treturn html.replace(/\\n/g, '').replace(/(>)(?:\\s+)(<)/g, '$1$2');\r\n\t},\r\n\r\n    /**\r\n     * @description Sort a element array by depth of element.\r\n     * @param {Array} array Array object\r\n     * @param {Boolean} des true: descending order / false: ascending order\r\n     */\r\n    sortByDepth: function (array, des) {\r\n        const t = !des ? -1 : 1;\r\n        const f = t * -1;\r\n\r\n        array.sort(function (a, b) {\r\n            if (!this.isListCell(a) || !this.isListCell(b)) return 0;\r\n            a = this.getElementDepth(a);\r\n            b = this.getElementDepth(b);\r\n            return a > b ? t : a < b ? f : 0;\r\n        }.bind(this));\r\n    },\r\n\r\n    _isExcludeSelectionElement: function (element) {\r\n        return !/FIGCAPTION/i.test(element.nodeName) && (this.isComponent(element) || /FIGURE/i.test(element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description Nodes that need to be added without modification when changing text nodes\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isIgnoreNodeChange: function (element) {\r\n        return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\r\n    },\r\n\r\n    /**\r\n     * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n     * @param {Node|String} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isMaintainedNode: function (element) {\r\n        return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Node with font-size style\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isSizeNode: function (element) {\r\n        return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\r\n    },\r\n\r\n    /**\r\n     * @description Nodes without text\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _notTextNode: function (element) {\r\n        return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @deprecated\r\n     * @description Check disallowed tags\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _disallowedTags: function (element) {\r\n        return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Create whitelist RegExp object.\r\n     * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n     * @param {String} list Tags list (\"br|p|div|pre...\")\r\n     * @returns {RegExp}\r\n     */\r\n    createTagsWhitelist: function (list) {\r\n        return new RegExp('<\\\\/?\\\\b(?!\\\\b' + (list || '').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\r\n    },\r\n\r\n    /**\r\n     * @description Create blacklist RegExp object.\r\n     * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?:\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n     * @param {String} list Tags list (\"br|p|div|pre...\")\r\n     * @returns {RegExp}\r\n     */\r\n    createTagsBlacklist: function (list) {\r\n        return new RegExp('<\\\\/?\\\\b(?:\\\\b' + (list || '^').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\r\n    },\r\n\r\n    /**\r\n     * @description Fix tags that do not fit the editor format.\r\n     * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n     * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n     * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)\r\n     * @param {Function} classNameFilter Class name filter function\r\n     * @private\r\n     */\r\n    _consistencyCheckOfHTML: function (documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, classNameFilter) {\r\n        /**\r\n         * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n         * So check the node type and exclude the text no (current.nodeType !== 1)\r\n         */\r\n        const removeTags = [], emptyTags = [], wrongList = [], withoutFormatCells = [];\r\n\r\n        // wrong position\r\n        const wrongTags = this.getListChildNodes(documentFragment, function (current) {\r\n            if (current.nodeType !== 1) {\r\n                if (this.isList(current.parentElement)) removeTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            // white list\r\n            if (htmlCheckBlacklistRegExp.test(current.nodeName) || (!htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current))) {\r\n                removeTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            // empty tags\r\n            const nrtag = !this.getParentElement(current, this.isNotCheckingNode);\r\n            if ((!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current)) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\r\n                emptyTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            // wrong list\r\n            if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\r\n                wrongList.push(current);\r\n                return false;\r\n            }\r\n\r\n            // table cells\r\n            if (this.isCell(current)) {\r\n                const fel = current.firstElementChild;\r\n                if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\r\n                    withoutFormatCells.push(current);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // class filter\r\n            if (nrtag && current.className) {\r\n                const className = new this._w.Array(current.classList).map(classNameFilter).join(' ').trim();\r\n                if (className) current.className = className;\r\n                else current.removeAttribute('class');\r\n            }\r\n\r\n            const result = current.parentNode !== documentFragment && nrtag &&\r\n             ((this.isListCell(current) && !this.isList(current.parentNode)) ||\r\n              ((this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent)));\r\n\r\n            return result;\r\n        }.bind(this));\r\n\r\n        for (let i = 0, len = removeTags.length; i < len; i++) {\r\n            this.removeItem(removeTags[i]);\r\n        }\r\n        \r\n        const checkTags = [];\r\n        for (let i = 0, len = wrongTags.length, t, p; i < len; i++) {\r\n            t = wrongTags[i];\r\n            p = t.parentNode;\r\n            if (!p || !p.parentNode) continue;\r\n\r\n            if (this.getParentElement(t, this.isListCell)) {\r\n                const cellChildren = t.childNodes;\r\n                for (let j = cellChildren.length - 1; len >= 0; j--) {\r\n                    p.insertBefore(t, cellChildren[j]);\r\n                }\r\n                checkTags.push(t);\r\n            } else {\r\n                p.parentNode.insertBefore(t, p);\r\n                checkTags.push(p);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = checkTags.length, t; i < len; i++) {\r\n            t = checkTags[i];\r\n            if (this.onlyZeroWidthSpace(t.textContent.trim())) {\r\n                this.removeItem(t);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = emptyTags.length; i < len; i++) {\r\n            this.removeItem(emptyTags[i]);\r\n        }\r\n\r\n        for (let i = 0, len = wrongList.length, t, tp, children, p; i < len; i++) {\r\n            t = wrongList[i];\r\n            p = t.parentNode;\r\n            if (!p) continue;\r\n\r\n            tp = this.createElement('LI');\r\n\r\n            if (this.isFormatElement(t)) {\r\n                children = t.childNodes;\r\n                while (children[0]) {\r\n                    tp.appendChild(children[0]);\r\n                }\r\n                p.insertBefore(tp, t);\r\n                this.removeItem(t);\r\n            } else {\r\n                t = t.nextSibling;\r\n                tp.appendChild(wrongList[i]);\r\n                p.insertBefore(tp, t);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = withoutFormatCells.length, t, f; i < len; i++) {\r\n            t = withoutFormatCells[i];\r\n            f = this.createElement('DIV');\r\n            f.innerHTML = (t.textContent.trim().length === 0 && t.children.length === 0) ? '<br>' : t.innerHTML;\r\n            t.innerHTML = f.outerHTML;\r\n        }\r\n    },\r\n\r\n    _setDefaultOptionStyle: function (options, defaultStyle) {\r\n        let optionStyle = '';\r\n        if (options.height) optionStyle += 'height:' + options.height + ';';\r\n        if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';\r\n        if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';\r\n        if (options.position) optionStyle += 'position:' + options.position + ';';\r\n        if (options.width) optionStyle += 'width:' + options.width + ';';\r\n        if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';\r\n        if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';\r\n\r\n        let top = '', frame = '', editor = '';\r\n        defaultStyle = optionStyle + defaultStyle;\r\n        const styleArr = defaultStyle.split(';');\r\n        for (let i = 0, len = styleArr.length, s; i < len; i++) {\r\n            s = styleArr[i].trim();\r\n            if (!s) continue;\r\n            if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\r\n                top += s + ';';\r\n                continue;\r\n            }\r\n            if (/^(min-|max-)?height\\s*:/.test(s)) {\r\n                if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {\r\n                    options.height = 'auto';\r\n                }\r\n                frame += s + ';';\r\n                continue;\r\n            }\r\n            editor += s + ';';\r\n        }\r\n\r\n        return {\r\n            top: top,\r\n            frame: frame,\r\n            editor: editor\r\n        };\r\n    },\r\n\r\n    _setIframeDocument: function (frame, options) {\r\n        frame.setAttribute('scrolling', 'auto');\r\n        frame.contentDocument.head.innerHTML = '' +\r\n            '<meta charset=\"utf-8\" />' +\r\n            '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">' +\r\n            this._setIframeCssTags(options);\r\n        frame.contentDocument.body.className = options._editableClass;\r\n        frame.contentDocument.body.setAttribute('contenteditable', true);\r\n    },\r\n\r\n    _setIframeCssTags: function (options) {\r\n        const linkNames = options.iframeCSSFileName;\r\n        const wRegExp = this._w.RegExp;\r\n        let tagString = '';\r\n\r\n        for (let f = 0, len = linkNames.length, path; f < len; f++) {\r\n            path = [];\r\n\r\n            if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\r\n                path.push(linkNames[f]);\r\n            } else {\r\n                const CSSFileName = new wRegExp('(^|.*[\\\\/])' + linkNames[f] + '(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$', 'i');\r\n                for (let c = document.getElementsByTagName('link'), i = 0, len = c.length, styleTag; i < len; i++) {\r\n                    styleTag = c[i].href.match(CSSFileName);\r\n                    if (styleTag) path.push(styleTag[0]);\r\n                }\r\n            }\r\n\r\n            if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\r\n\r\n            for (let i = 0, len = path.length; i < len; i++) {\r\n                tagString += '<link href=\"' + path[i] + '\" rel=\"stylesheet\">';\r\n            }\r\n        }\r\n\r\n        return tagString + (options.height === 'auto' ? '<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>' : '');\r\n    }\r\n};\r\n\r\nexport default util;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}